<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fall Out Boy</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="blog.lovelaolao.xin/"/>
  <updated>2018-08-21T15:47:05.000Z</updated>
  <id>blog.lovelaolao.xin/</id>
  
  <author>
    <name>Hou Zhe</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>FM FFM DeepFM</title>
    <link href="blog.lovelaolao.xin/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/FM-FFM-DeepFM/"/>
    <id>blog.lovelaolao.xin/机器学习/FM-FFM-DeepFM/</id>
    <published>2018-08-19T14:48:00.000Z</published>
    <updated>2018-08-21T15:47:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>一般的线性模型是不考虑特征交叉的。<br>$y = w_0 + \sum_{i=1}^nw_ix_i$<br>二阶多项式模型会考虑所有两个特征交叉的情况。即 n<em>(n-1)/2 种特征。<br>**注意：这里的交叉部分是从<code>i = 1到n</code>\</em><code>j = i+1到n</code>，避免重复交叉**。<br>且交叉的是样本，而不是特征。<br>$y(\mathbf{x}) = w_0+ \sum_{i=1}^n w_i x_i + \sum_{i=1}^n \sum_{j=i+1}^n w_{ij} x_i x_j \label{eq:poly}\tag{1}$<br>如果特征交叉的维度再提升的话会带来非常高的复杂度。</p><h1 id="FM（Factorization-Machines）"><a href="#FM（Factorization-Machines）" class="headerlink" title="FM（Factorization Machines）"></a>FM（Factorization Machines）</h1><p><a href="https://www.csie.ntu.edu.tw/~b97053/paper/Rendle2010FM.pdf" target="_blank" rel="noopener">paper</a><br>目标：解决数据稀疏的情况下，特征怎样组合的问题 </p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>首先要做的是对所有特征做<strong>one hot编码</strong>。<ul><li>比如：特征年龄：中年、青年、老年。就会变成是否中年、是否青年、是否老年三个特征。<ul><li>这样，特征空间会迅速变大。</li><li>但是特征会变得很稀疏。</li></ul></li><li>好处：将离散特征每一个取值都拆分成一个特征非常适合特征交叉。会产生很有意义的特征。<ul><li>比如加上职业，不会是年龄+程序员，而是中年程序员、青年程序员、老年程序员。</li></ul></li><li>（其实在第二个式子中已经有二阶多项式的实现方式）<ul><li>但是由于每个wij都需要大量非零样本来训练，然而稀疏的one hot特征会让非零样本很少，所以是不可训练的。</li></ul></li></ul></li><li>解决二次项参数训练问题：<strong>矩阵分解</strong>。<ul><li><strong>其实就是二阶多项式的 wij（nxn）其实就构成了一个所有样本公用的权重矩阵 W，而<code>V转置xV</code>的形式刚好可以让（nxk x kxn）的两个矩阵得到（nxn）的目标权重矩阵W，k可以是一个灵活的值。</strong><ul><li><strong>这样就相当于把求解一个（nxn）的W矩阵变成求解（kxn）的 V 矩阵，从而把 n^2 的参数量变成了 kxn 的（伪）线性参数量。</strong></li></ul></li><li>比如：在 model-based 的协同过滤问题对 user 向量矩阵和 item 向量矩阵<strong>点乘</strong>得到user、item矩阵的做法。（矩阵中每一个值就是user-item的一个打分）<img src="https://tech.meituan.com/img/deep-understanding-of-ffm-principle-and-practice/ffm_mf.png" alt=""></li><li>做法：借鉴协同过滤的做法，把所有的二次项参数 wij 组成为一个矩阵 W，$\mathbf{W} = \mathbf{V}^T \mathbf{V}$，其中V矩阵就是特征的矩阵，V的第j列就是j特征的所有样本取值。<ul><li>所以其实W是由V自己<strong>点乘</strong>自己得到的，也就肯定是一个对称矩阵。</li></ul></li><li><strong>公式：</strong>$y(\mathbf{x}) = w_0+ \sum_{i=1}^n w_i x_i + \sum_{i=1}^n \sum_{j=i+1}^n \langle \mathbf{v}_i, \mathbf{v}_j \rangle x_i x_j \label{eq:fm}\tag{2}$<ul><li>其中vi代表第i位特征的隐向量。&lt;·,·&gt;代表点乘，n 为特征数量，x 就是输入的一个样本。（也就是对于一个样本，得到他的结果，由这个公式计算）</li><li>由于<strong>每个 V 特征向量都相当于一个特征的隐向量，本身没有直接意义，但是和其他特征的隐向量点乘得到的值会成为一个交叉特征的权重</strong>。且 Vi 的长度k&lt;&lt;n。</li></ul></li><li>好处：<strong>总参数量为 kxn</strong><ul><li>参数量由 n^2 变成了 kxn 的线性，并且在普通的二阶多项式模型里wij和wji是相互独立的。但是在矩阵分解的做法里，两者是一样的。</li><li>比如 wij 和 whj ，矩阵分解的做法会让 vj 和vi、vh都产生关系。也就意味着vi、vh都对vj的学习产生作用。从稀释了稀疏特征的很多0让 wij 其实没卵用的影响。</li></ul></li></ul></li><li><strong>扩展</strong>：上面矩阵分解的公式是一个通用的基础。在此基础上可以引入不同的损失函数，解决回归、分类问题。（其实就是<code>∑wixi</code>和<code>∑∑&lt;vi, vj&gt;xixj</code>的变形。）</li><li><strong>训练/计算时间复杂度问题</strong>：参数量虽然下降到了线性，但是要计算y(x)的损失，因为<code>∑∑&lt;vi, vj&gt;xixj</code>存在使时间复杂度为O(k*n^2)。<ul><li>解决：由于<code>i = 1到n</code> <code>j = i+1到n</code>，也就是对称矩阵对角线的上半部分。那么原公式就可以转化为<code>1/2(整个矩阵做特征交叉-对角线的特征交叉)</code>，经过一堆骚操作可以把公式简化为：$\sum_{i=1}^n \sum_{j=i+1}^n \langle \mathbf{v}_i, \mathbf{v}_j \rangle x_i x_j = \frac{1}{2} \sum_{f=1}^k \left(\left( \sum_{i=1}^n v_{i, f} x_i \right)^2 - \sum_{i=1}^n v_{i, f}^2 x_i^2 \right) \label{eq:fm_conv}\tag{3}$</li><li><code>f = 1到k</code>为vi的第f个元素。可以看到 j 神奇的消失了= =（因为实际本身就需要一个 wij 做交叉特征的权重，求梯度的时候也就一个偏导，不是对i、j各求一个。而特殊的化简方式里放弃了<code>j = i+1到n</code>的关系，直接用 i 代替 j 。并且化简了i、j两层循环，变成i一层循环但是里面有平方的形式。）</li><li>所以<strong>计算损失的时间复杂度为O(kn)</strong>。</li><li>偏导：$\sum_{j=1}^n v_{j, f} x_j$<ul><li>可以看到特别一点的只有交叉特征权重的偏导：<code>vif的偏导</code>指特征 i 的隐含向量中第 f 元素的偏导。其中$\sum_{j=1}^n v_{j, f} x_j$是求 y(x) 时已经算过的东西了。</li><li>所以<strong>求偏导的时间复杂度为O(1)</strong></li></ul></li></ul></li></ul><h2 id="FM的优势"><a href="#FM的优势" class="headerlink" title="FM的优势"></a>FM的优势</h2><ul><li>灵活：通过合适的特征变换方式，FM 可以模拟二阶多项式核的 SVM 模型、MF 模型、SVD++ 模型等。</li><li>样本稀疏的情况下天然适合 FM 发挥。</li><li>训练、预测、参数量均是线性的。</li><li>对于 FM 的特征交叉方式而言，可以添加任意多的特征，除了 one hot 还可以用均值等等内容做特征。</li></ul><h1 id="FFM（Field-aware-Factorization-Machine）"><a href="#FFM（Field-aware-Factorization-Machine）" class="headerlink" title="FFM（Field-aware Factorization Machine）"></a>FFM（Field-aware Factorization Machine）</h1><p>非常适用于 CTR、CVR 问题上。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><ul><li><strong>field</strong>：引入了 field 的概念，就是把经过 one hot 处理过的离散特征，比如：年龄有青年、中年、老年。可以处理为三个二分类特征。这三个特征会放到同一个 field 中来处理。连续特征的话可以直接看为一个 field或进行特征离散化。  <ul><li>每一维特征都会对其他特征所有的 field 为单位学习一个隐向量$\mathbf{v}_{i, f_j}$（含义：特征 i 的 f 个隐向量中对应 field j 那个）。<ul><li>即：每个特征 f 个隐向量。（f 为所有特征一共在 f 个field）</li><li>也就是<strong>一共有 <code>nxf</code> 个隐向量</strong>。</li><li>如果每个隐向量长度为 k，也就是<strong>一共有 <code>kxnxf</code> 个交叉特征参数</strong>。</li></ul></li><li>好处：将特征间的隐向量做了隔离，能专门取学习不同特征间 field 交叉的信息。</li></ul></li><li><strong>复杂度</strong>：<ul><li><strong>公式</strong>：$y(\mathbf{x}) = w_0 + \sum_{i=1}^n w_i x_i + \sum_{i=1}^n \sum_{j=i+1}^n \langle \mathbf{v}_{i, f_j}, \mathbf{v}_{j, f_i} \rangle x_i x_j \label{eq:ffm}\tag{4}$也就是计算交叉特征权重的方式中引入了field。</li><li>预测/复杂度：<strong>O(k*n^2)</strong>。</li><li>特别的，由于每个特征都维护了一个<code>fxk</code>的矩阵，来表达一个 field 和其他所有 field 做特征交叉的权重。在更新梯度的时候套路还是一样，只是要更新到的特征空间更加复杂。</li></ul></li><li>特征表示：<code>field_id:feat_id:value</code>，feat_id 为特征编号。</li></ul><h2 id="论文"><a href="#论文" class="headerlink" title="论文"></a>论文</h2><p><a href="https://www.csie.ntu.edu.tw/~cjlin/papers/ffm.pdf" target="_blank" rel="noopener">paper</a><br>在该论文中对正负样本处理成了1、-1.<br>损失函数选择了交叉熵。<br>求偏导时用到了链式法则。</p><h1 id="DeepMF"><a href="#DeepMF" class="headerlink" title="DeepMF"></a>DeepMF</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一般的线性模型是不考虑特征交叉的。&lt;br&gt;$y = w_0 + \sum_{i=1}^nw_ix_i$&lt;br&gt;二阶多项式模型会考虑所有两个特征交叉的情况。即 n&lt;em&gt;(n-1)/2 种特征。&lt;br&gt;**注意：这里的交叉部分是从&lt;code&gt;i = 1到n&lt;/code&gt;\&lt;/
      
    
    </summary>
    
      <category term="机器学习" scheme="blog.lovelaolao.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="推荐" scheme="blog.lovelaolao.xin/tags/%E6%8E%A8%E8%8D%90/"/>
    
      <category term="CTR模型" scheme="blog.lovelaolao.xin/tags/CTR%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Array-Hard难度刷题总结</title>
    <link href="blog.lovelaolao.xin/Algorithm/Array/Hard/Leetcode%E8%8A%82%E5%A5%8FArrayhard/"/>
    <id>blog.lovelaolao.xin/Algorithm/Array/Hard/Leetcode节奏Arrayhard/</id>
    <published>2018-06-06T15:32:00.000Z</published>
    <updated>2018-06-09T09:10:07.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>很暴力的做法回溯也是很常见的做法。</p><h2 id="未来可以继续做的hard题"><a href="#未来可以继续做的hard题" class="headerlink" title="未来可以继续做的hard题"></a>未来可以继续做的hard题</h2><p><strong><code>715、123、85、57、84、719、4</code></strong><br>时间来不及的话建议想想差不多就看discuss，不要占用一个半小时以上的时间。</p><h2 id="2018-4-8-Max-Chunks-To-Make-Sorted-II-Hard"><a href="#2018-4-8-Max-Chunks-To-Make-Sorted-II-Hard" class="headerlink" title="2018.4.8-Max Chunks To Make Sorted II-Hard"></a>2018.4.8-Max Chunks To Make Sorted II-Hard</h2><p><strong>dp 贪心</strong></p><blockquote><p>将一个数组分成多个块，如果对每个块排序，按照块的顺序组装起来能得到全排序的数组，那么最多能分多少块。</p></blockquote><p>相当于保证所有块中按顺序<code>块k的max</code>&lt;=<code>块k+1的min</code>。</p><pre><code>我的做法：dp+贪心用dp[i]保存前i个元素里的最大的那个。然后从后往前遍历，用一个min保存后面元素里的最小值。遍历到i的min和dp[i-1]比较。每当min&gt;dp[i-1]，更新min为arr[i-1]，然后块数+1。否则更新min。</code></pre><p>一次AC，beat88%。<br><a id="more"></a></p><h3 id="2018-5-8-My-Calendar-II-III-Medium-Hard"><a href="#2018-5-8-My-Calendar-II-III-Medium-Hard" class="headerlink" title="2018.5.8-My Calendar II/III-Medium/Hard"></a>2018.5.8-My Calendar II/III-Medium/Hard</h3><p>说实话有点为难而难，没什么值得做的，全是边缘控制。太多if else而没什么技术含量。</p><h2 id="2018-5-29-Maximum-Sum-of-3-Non-Overlapping-Subarrays-Hard—有点别扭"><a href="#2018-5-29-Maximum-Sum-of-3-Non-Overlapping-Subarrays-Hard—有点别扭" class="headerlink" title="2018.5.29-Maximum Sum of 3 Non-Overlapping Subarrays-Hard—有点别扭"></a>2018.5.29-Maximum Sum of 3 Non-Overlapping Subarrays-Hard—有点别扭</h2><p><strong>DP、贪心，想清楚流程</strong></p><blockquote><p>给定一个正整数数组及每个子数组长度k，找到三个连续且不互相覆盖的子数组，使其和最大。返回三个子数组的起点位置。<br>若存在多个解，选序列最小的。<br>Input: [1,2,1,2,6,7,5,1], 2<br>Output: [0, 3, 5]<br>Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].<br>We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.</p></blockquote><p>可以说是非常非常绕的题了。。。做了好久好久，好在是靠自己做了出来。  </p><h3 id="想法说明："><a href="#想法说明：" class="headerlink" title="想法说明："></a>想法说明：</h3><p>首先给出了限定找到<strong>3个</strong>不互相覆盖的连续子数组。这样就限制了问题的规模和所需的空间。<br>然后从例子的结果上看，这种题肯定可以用回溯判断所有三个子数组来找到最佳答案。相当于是穷举的做法，肯定没毛病，但是不用写就知道不管是在面试还是在leetcode上都是没办法通过的。  </p><p>明显这三个子数组是有先后顺序的，那么就可以尝试用DP来试试能不能分解出子问题。当然可以，但是是可以分解为两个维度上的子问题：<code>数组前i个数所能找到的最大和j个子数组</code>和<code>数组前i个数所能找到的最大和3、2、1个子数组</code>（这里注意必须保证划分的子问题最少有3*k个数）。</p><p>接下来就要考虑如何从比如<code>数组前i个数的最大和1个子数组</code>到<code>前i个数的最大和2个子数组</code>的升维。这里需要用到贪心。具体如下：</p><pre><code>我的解法：（AC-beat35%）准备一个数组dp[len][4]。dp[i][0]用于保存前i个数j个子数组的最大和是几。dp[i][1,2,3]分别保存前i个数的是三个子数组结果的起始位置。1. 一次dp：先求第一个所有连续k长度的子数组，并找到前i个数的最大连续子数组和及其起始点。（注意数的范围是0~len-2*k-1）2. 再求第二个所有连续k长度的子数组（数的范围是k~len-k-1），每个第二个连续k长度子数组都直接加上其起始位置之前所有数的最大和第一个连续k长度子数组（第一步已知）。    这样就得到了每个第二个连续k长度子数组所能得到的最大和的两个k长度子数组。3. 第二次dp：将所有的最大和两个连续k长度子数组的和，遍历一遍，得到前i个数的两个最大连续子数组和及其起始点。4. 再仿照进行一次第2、3步，就能得到前i个数的3个最大连续子数组和及其起始点。也就得到了结果。（进行第三次dp，数的范围是2*k~len-1）其实解法里存在一些空间、时间浪费，但是实在是不想去细细考察了。我在写的时候只是简单地复制了两次代码来求第二第三个子数组，当问题扩展了，完全可以设计一个递归函数来做。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line">附代码：这是我写的最多字的leetcode的了= =。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; k*<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(len == k*<span class="number">3</span>) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            res[<span class="number">1</span>] = k;</span><br><span class="line">            res[<span class="number">2</span>] = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">4</span>];<span class="comment">//dp[1,2,3]分别是其最大值第1，2，3段所在起点</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, max = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; i++) sum+=nums[i];</span><br><span class="line">        dp[k-<span class="number">1</span>][<span class="number">0</span>] = sum;</span><br><span class="line">        dp[k-<span class="number">1</span>][<span class="number">1</span>] = pos;</span><br><span class="line">        max = sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i&lt;len-<span class="number">2</span>*k; i++)&#123;</span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">                max = sum;</span><br><span class="line">                pos = i-k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max;</span><br><span class="line">            dp[i][<span class="number">1</span>] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        pos = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i&lt;<span class="number">2</span>*k; i++) sum+=nums[i];</span><br><span class="line">        dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">2</span>] = sum+dp[k-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i&lt;len-k; i++)&#123;</span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            dp[i][<span class="number">2</span>] = sum+dp[i-k][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">2</span>] = pos;</span><br><span class="line">        max = dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i&lt;len-k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">2</span>] &gt; max)&#123;</span><br><span class="line">                max = dp[i][<span class="number">2</span>];</span><br><span class="line">                pos = i-k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max;</span><br><span class="line">            dp[i][<span class="number">2</span>] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        pos = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i&lt;<span class="number">3</span>*k; i++) sum+=nums[i];</span><br><span class="line">        dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">3</span>] = sum+dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>*k; i&lt;len; i++)&#123;</span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = sum+dp[i-k][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">3</span>] = pos;</span><br><span class="line">        max = dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>*k; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">3</span>] &gt; max)&#123;</span><br><span class="line">                max = dp[i][<span class="number">3</span>];</span><br><span class="line">                pos = i-k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max;</span><br><span class="line">            dp[i][<span class="number">3</span>] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        res[<span class="number">2</span>] = dp[len-<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        res[<span class="number">1</span>] = dp[dp[len-<span class="number">1</span>][<span class="number">3</span>]-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = dp[dp[dp[len-<span class="number">1</span>][<span class="number">3</span>]-<span class="number">1</span>][<span class="number">2</span>]-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">```</span><br><span class="line">## 2018.6.5-Longest Consecutive Sequence-Hard---回来看看</span><br><span class="line">**问题建模**</span><br><span class="line">&gt;给定整数数组，找到其中能凑出的连续数字的最大长度。要求时间复杂度为O(N)。   </span><br><span class="line">&gt;Input: [<span class="number">100</span>, <span class="number">4</span>, <span class="number">200</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>]  </span><br><span class="line">Output: <span class="number">4</span>  </span><br><span class="line">Explanation: The longest consecutive elements sequence is [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]. Therefore its length is <span class="number">4</span>.</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">我的思路：（方向正确，接近正答，但是想复杂了些）</span><br><span class="line">最简单的做法当然是先排序，但是必然是不满足O(N)了。</span><br><span class="line">想要实现O(N)，必然是边遍历边搞定。</span><br><span class="line">直观的经过遍历的过程不断凑出来最长连续数字。</span><br><span class="line">可以看出来，只有两种组合连续数字的方式。</span><br><span class="line"><span class="number">1</span>. 要么一个数可以组到其他连续数字里。如<span class="number">1</span>，<span class="number">2</span> + <span class="number">3</span></span><br><span class="line"><span class="number">2</span>. 要么一个数在两个连续数字集合的中间，将两个连续数字集合合并。如：<span class="number">1</span>，<span class="number">3</span> + <span class="number">2</span></span><br><span class="line">其实很明显，如果可以丰富连续数字，那么新的数字一定在一个/两个已知连续数字的边缘+-<span class="number">1</span>。</span><br><span class="line">那么我打算用两个map来辅助。</span><br><span class="line">s代表每个连续数字集合的开始-&gt;结束。</span><br><span class="line">e代表每个连续数字集合的结束-&gt;开始。</span><br><span class="line">所以其实s、e互为reverse。</span><br><span class="line">那么：</span><br><span class="line"><span class="number">1</span>. 如果遇到s、e里没有的，加入进去。（最后判断）</span><br><span class="line"><span class="number">2</span>. 如果存在s(i+<span class="number">1</span>)/e(i-<span class="number">1</span>)代表可以把i加入到某个连续数字集合。</span><br><span class="line"><span class="number">3</span>. 如果都存在，代表可以通过i合并两个数字集合。</span><br><span class="line"><span class="number">4</span>. 更新过程维护max。</span><br><span class="line"><span class="number">2</span>、<span class="number">3</span>需要去更新原数字集合的s、e。</span><br><span class="line">看起来很合理，但是存在一个bug：重复的数字。</span><br><span class="line">因为这种存储数据结构可以很好地表示连续数字的起终点，但是无法侦测一个数是否存在于某个区间，除非遍历所有map（时间不允许）。</span><br><span class="line">一旦出现重复的数字，就有可能出现连续数字边缘位置重复的问题。</span><br><span class="line"></span><br><span class="line">正答：（AC-beat8%）</span><br><span class="line">问题的关键确实是连续数字的边缘位置。也是用两个map存储。</span><br><span class="line">但是存储方式是l、r两个map，分别代表一个位置i的左侧、右侧（包括自己）最大连续数字长度。</span><br><span class="line">那么：（默认会做合并操作）</span><br><span class="line"><span class="number">1</span>. 计算当前数字i的左右各能连续多少数字（没有是<span class="number">0</span>）。</span><br><span class="line"><span class="number">2</span>. 那么数字i能合并出来的最大长度就是len。</span><br><span class="line"><span class="number">3</span>. 由<span class="number">1</span>可知数字i所在连续数字集合的左右边缘外位置。</span><br><span class="line"><span class="number">4</span>. 由于合并了i得到新的集合，那么去更新两侧边缘位置value为len。</span><br><span class="line">这样做看似因为合并之后没有去更新数字集合内其他位置已经变化的左右长度。</span><br><span class="line">但是要知道，如果一个数字i真正带来了合并，那么l、r里必然已经存在数字集合里的所有数字。</span><br><span class="line">那么这里面出现过的数字，周围再出现肯定是重复的，其len肯定不会再变大了。所以不用管了。</span><br><span class="line">所以，这样的操作就会不断去更新每个连续数字集合边缘位置其向左、右能达到的最远。最终就能得到结果。</span><br></pre></td></tr></table></figure><h2 id="2018-6-5-Trapping-Rain-Water-Hard—👍👍"><a href="#2018-6-5-Trapping-Rain-Water-Hard—👍👍" class="headerlink" title="2018.6.5-Trapping Rain Water-Hard—👍👍"></a>2018.6.5-Trapping Rain Water-Hard—👍👍</h2><p><strong>双指针思想，问题建模</strong>。</p><blockquote><p>给定一个整数数组，分别代表一个柱状图柱子高度，返回该图像所能积累的水滴数。<br><img src="https://leetcode.com/static/images/problemset/rainwatertrap.png" alt="avatar"><br>Input: [0,1,0,2,1,0,1,3,2,1,2,1]<br>Output: 6</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">我的思路：（有些接近正答的想法）</span><br><span class="line">当然最简单的做法就是一层层遍历，从height=<span class="number">0</span>到height=maxheight，一层层数能放多少水。</span><br><span class="line">但是这种做法很容易就被数组容量和maxheight的大小所打败。</span><br><span class="line">不这样的话---&gt;</span><br><span class="line">其他呢没有太好的想法，但是当时有借助dp想到接近了正答的方向。懒得总结了。</span><br><span class="line"></span><br><span class="line">正答：（AC-beat20%）</span><br><span class="line">首先要想到这样一个常识，一个桶能装多少水，完全取决于左右桶壁较低那个的高度及桶的底面积大小。</span><br><span class="line">而这道题，不应该从小到大看，而应该从大到小看。</span><br><span class="line">也就是看成一个大桶里有多个小桶的情况。</span><br><span class="line">当大桶的壁可以确定，那么里面不管是什么情况，肯定能确定最起码可以装多少水不是吗。</span><br><span class="line">那么就用左右指针代表桶的左右壁的移动位置，用两个变量保存左右壁目前的最大值。</span><br><span class="line">不断移动较低的壁向中间移动，如果矮于原高度就计入能装杜少水，如果高于，就更新壁。</span><br><span class="line">直到左右指针相遇。</span><br><span class="line"></span><br><span class="line">代码：</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">trap</span><span class="params">(<span class="keyword">int</span>[] height)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = height.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; <span class="number">3</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = len-<span class="number">1</span>, lw = height[l], rw = height[r], count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(lw &lt; rw)&#123;</span><br><span class="line">                count += lw - height[l];</span><br><span class="line">                l++;</span><br><span class="line">                lw = lw &gt; height[l] ? lw : height[l];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                count += rw - height[r];</span><br><span class="line">                r--;</span><br><span class="line">                rw = rw &gt; height[r] ? rw : height[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Array&quot;&gt;&lt;a href=&quot;#Array&quot; class=&quot;headerlink&quot; title=&quot;Array&quot;&gt;&lt;/a&gt;Array&lt;/h1&gt;&lt;p&gt;很暴力的做法回溯也是很常见的做法。&lt;/p&gt;
&lt;h2 id=&quot;未来可以继续做的hard题&quot;&gt;&lt;a href=&quot;#未来可以继续做的hard题&quot; class=&quot;headerlink&quot; title=&quot;未来可以继续做的hard题&quot;&gt;&lt;/a&gt;未来可以继续做的hard题&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;&lt;code&gt;715、123、85、57、84、719、4&lt;/code&gt;&lt;/strong&gt;&lt;br&gt;时间来不及的话建议想想差不多就看discuss，不要占用一个半小时以上的时间。&lt;/p&gt;
&lt;h2 id=&quot;2018-4-8-Max-Chunks-To-Make-Sorted-II-Hard&quot;&gt;&lt;a href=&quot;#2018-4-8-Max-Chunks-To-Make-Sorted-II-Hard&quot; class=&quot;headerlink&quot; title=&quot;2018.4.8-Max Chunks To Make Sorted II-Hard&quot;&gt;&lt;/a&gt;2018.4.8-Max Chunks To Make Sorted II-Hard&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;dp 贪心&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;将一个数组分成多个块，如果对每个块排序，按照块的顺序组装起来能得到全排序的数组，那么最多能分多少块。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;相当于保证所有块中按顺序&lt;code&gt;块k的max&lt;/code&gt;&amp;lt;=&lt;code&gt;块k+1的min&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;我的做法：dp+贪心
用dp[i]保存前i个元素里的最大的那个。
然后从后往前遍历，用一个min保存后面元素里的最小值。
遍历到i的min和dp[i-1]比较。
每当min&amp;gt;dp[i-1]，更新min为arr[i-1]，然后块数+1。否则更新min。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;一次AC，beat88%。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="blog.lovelaolao.xin/categories/Algorithm/"/>
    
      <category term="Array" scheme="blog.lovelaolao.xin/categories/Algorithm/Array/"/>
    
      <category term="Hard" scheme="blog.lovelaolao.xin/categories/Algorithm/Array/Hard/"/>
    
    
      <category term="Array" scheme="blog.lovelaolao.xin/tags/Array/"/>
    
      <category term="Leetcode" scheme="blog.lovelaolao.xin/tags/Leetcode/"/>
    
      <category term="Hard" scheme="blog.lovelaolao.xin/tags/Hard/"/>
    
  </entry>
  
  <entry>
    <title>Array-Medium难度刷题总结</title>
    <link href="blog.lovelaolao.xin/Algorithm/Array/Medium/Leetcode%E8%8A%82%E5%A5%8FArraymedium/"/>
    <id>blog.lovelaolao.xin/Algorithm/Array/Medium/Leetcode节奏Arraymedium/</id>
    <published>2018-06-06T15:32:00.000Z</published>
    <updated>2018-06-09T09:10:19.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h1><p>很暴力的做法回溯也是很常见的做法。</p><h2 id="2018-4-1-Maximum-Product-of-Three-Numbers-Medium"><a href="#2018-4-1-Maximum-Product-of-Three-Numbers-Medium" class="headerlink" title="2018.4.1-Maximum Product of Three Numbers-Medium"></a>2018.4.1-Maximum Product of Three Numbers-Medium</h2><p><strong>多局部标记</strong></p><blockquote><p>从一个数组中找到三个数，使其乘积max。</p></blockquote><pre><code>我的做法：    用堆排序，得到正数的前三个，负数的后两个。    但是你怎么知道建立多大的堆呢？    一旦遍历得到大小，那就意味着失去了堆排序的优势了。    但是必须得得到大小啊。。所以错。正答：    遍历一遍就可以了。不断更新五个临时变量。    但是注意，初始化是Integer.MAX/MIN_VALUE，否则无法分辨全是负数的情况。</code></pre><a id="more"></a><h2 id="2018-4-8-Combination-Sum-III-Medium"><a href="#2018-4-8-Combination-Sum-III-Medium" class="headerlink" title="2018.4.8-Combination Sum III-Medium"></a>2018.4.8-Combination Sum III-Medium</h2><p><strong>回溯</strong></p><blockquote><p>给定k和n，用k个1~9的数相加得到n。给出所有不含重复数的去重结果。</p></blockquote><p>回溯+差错控制+循环剪枝，就达到了beat100%。</p><h2 id="2018-5-5-Subarray-Product-Less-Than-K-Medium"><a href="#2018-5-5-Subarray-Product-Less-Than-K-Medium" class="headerlink" title="2018.5.5-Subarray Product Less Than K-Medium"></a>2018.5.5-Subarray Product Less Than K-Medium</h2><p><strong>窗口遍历</strong></p><blockquote><p>Your are given an array of positive integers nums.<br>Count and print the number of (contiguous) subarrays where the product of all the elements in the subarray is less than k.</p><p>Input: nums = [10, 5, 2, 6], k = 100<br>Output: 8<br>Explanation: The 8 subarrays that have product less than 100 are: [10], [5], [2], [6], [10, 5], [5, 2], [2, 6], [5, 2, 6].<br>Note that [10, 5, 2] is not included as the product of 100 is not strictly less than k.</p></blockquote><p>其实就是找到给定正数组所有连续子数组中，连乘&lt;k的有多少种。</p><pre><code>我的解法：（AC-beat36%）首先看似子问题比较好定义，所以想用dp，但是由父问题到子问题是需要知道每一种情况的乘积是多少才能继续判断。所以基本上是不行的。重要信息：连续。所以实际上就是查看从头到尾每一个元素开头所能组成的所有可能连续子串。由于顺序是从头到尾，那么上一个数的最长子串长度，必然满足下一个数。所以其实就是窗口移动了。int head, tail, count, product.用头尾记录窗口位置，product记录目前的乘积。主循环是head++，内部从上一个数的tail开始找到最远tail。每次head后移，都加一次本窗口内可以的子串数（限定了开头是当前head）。直到head、tail都到length的长度。O(N)，因为主循环head是从0到len-1，其实tail也是不会倒退，当达到len-1也就停止了。一共2N次移动。特别的：需要判断循环内部的细节关系。</code></pre><h2 id="2018-5-5-Minimum-Size-Subarray-Sum-Medium"><a href="#2018-5-5-Minimum-Size-Subarray-Sum-Medium" class="headerlink" title="2018.5.5-Minimum Size Subarray Sum-Medium"></a>2018.5.5-Minimum Size Subarray Sum-Medium</h2><p><strong>窗口遍历</strong></p><blockquote><p>Given an array of n positive integers and a positive integer s, find the minimal length of a contiguous subarray of which the sum ≥ s. If there isn’t one, return 0 instead.</p><p>Input: [2,3,1,2,4,3], s = 7<br>Output: 2<br>Explanation: the subarray [4,3] has the minimal length under the problem constraint.</p></blockquote><pre><code>我的解法：（AC-beat99.96%）用两个指针计算窗口，保留一个连续足够大的子串。主循环是后指针，一个个后移。当后移之后循环前指针能不能后移。用局部变量保存最短长度。特别的：当找到第一个足够大的子串，如果tail是最后了已经，那不代表就是答案，可能前指针还是可以后移。如：[1、2、3、4、5]，11恶心就恶心在有许多边界条件需要判断= =。</code></pre><h2 id="2018-5-5-Unique-Paths-II-Medium"><a href="#2018-5-5-Unique-Paths-II-Medium" class="headerlink" title="2018.5.5-Unique Paths II-Medium"></a>2018.5.5-Unique Paths II-Medium</h2><p><strong>dp</strong></p><blockquote><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p></blockquote><blockquote><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).<br>但是矩阵中会有0、1的区分，1代表有障碍物不能通过。</p></blockquote><pre><code>我的解法：当然是dp，但是这道题只能dp不能用排列组合直接计算。</code></pre><h2 id="2018-5-6-Merge-Intervals-Meduim—正答👍"><a href="#2018-5-6-Merge-Intervals-Meduim—正答👍" class="headerlink" title="2018.5.6-Merge Intervals-Meduim—正答👍"></a>2018.5.6-Merge Intervals-Meduim—正答👍</h2><p><strong>sort, two pointer， 单独排序+整体考察</strong>    </p><blockquote><p>Given a collection of intervals, merge all overlapping intervals.<br>Input: [[1,3],[2,6],[8,15],[15,18]]<br>Output: [[1,6],[8,18]]  </p></blockquote><blockquote><p>public class Interval {<br>     int start;<br>     int end;<br>     Interval() { start = 0; end = 0; }<br>     Interval(int s, int e) { start = s; end = e; }<br> }  </p></blockquote><pre><code>我的做法：（AC-beat9%）（基数排序）先对Interval类的end排序，在对start排序，保证判断的时候按顺序判断。用head、tail遍历一遍元素，合并所有重叠的，删掉所有被合并的。由于删除比较耗时间，排序两遍，有些多余。所以时间不咋地。优化：（AC-beat37%）只对start排序，end不用排序，只需要检查是否被包含在head里了。不用remove，用head保存所有合并集合，用tail正常遍历。最后只返回head之前的。如果还想提升- -，那只能不排序了是吧。最快正答：（beat99%）将Interval对象的所有start、end全部取出来组成两个int[]。分别Arrays.sort。假设start的每一个和end的每一个有对应关系。用j统计被合并数量。主循环循环start[i]，当有start[i]&lt;end[i+1]，加入{start[j], end[i]}，j=i+1.</code></pre><p>正答思想：</p><ul><li>首先说什么是合并：当是有序的时候，一定可以将第一次出现前者end小于后者start的情况之前的元素全部合并。</li><li>所以分成start、end两个数组，放弃之前的一一对应关系，就在于这个原理，不管他们之前是怎么对应的。当出现第一次前者end小于后者start，那么从这个前者及以前的所有元素的start、end就是可以合并的所有数的start、end。之前的元素一定可以合并。</li></ul><h2 id="2018-5-6-3Sum-Closest-Medium"><a href="#2018-5-6-3Sum-Closest-Medium" class="headerlink" title="2018.5.6-3Sum Closest-Medium"></a>2018.5.6-3Sum Closest-Medium</h2><blockquote><p>给一个数组，找到三个数之和离target最近的sum。</p></blockquote><pre><code>我的解法：（AC-beat88%）easy，就是3-sum问题，但是不能用map，因为map用于精确查找。先排序，用一个指针顺序遍历，两个指针从头、尾遍历。需要记录目前最近结果不断更新。</code></pre><h2 id="2018-5-6-Search-for-a-Range-Medium"><a href="#2018-5-6-Search-for-a-Range-Medium" class="headerlink" title="2018.5.6-Search for a Range-Medium"></a>2018.5.6-Search for a Range-Medium</h2><p><strong>二分查找</strong></p><blockquote><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.<br>Your algorithm’s runtime complexity must be in the order of O(log n).<br>If the target is not found in the array, return [-1, -1].</p></blockquote><p>easy，二分查找然后向两侧扩张。</p><h2 id="2018-5-6-Word-Search-Medium-👍👍"><a href="#2018-5-6-Word-Search-Medium-👍👍" class="headerlink" title="2018.5.6-Word Search-Medium-👍👍"></a>2018.5.6-Word Search-Medium-👍👍</h2><p><strong>dfs+visit+递归设计+矩阵方向循环遍历</strong><br>非常不错的一道题，很经典的DFS。</p><ul><li>需要递归的细节设计，在入口判断可行，在出口随意继续递归</li><li>需要visit矩阵保存本次dfs的路径<ul><li>注意：visit[][]矩阵是一个对象，不管如何复制都是全局共享修改的</li><li>处理：dfs其实是单个支线走到头，入栈出栈的过程，所以入栈时标记，出栈时还原visit就好了</li></ul></li><li>需要判断矩阵四个方向，但是用全局变量directions=[[1,0], [-1,0], [0,1], [0,-1]]循环判断</li></ul><blockquote><p>Given a 2D board and a word, find if the word exists in the grid.</p></blockquote><blockquote><p>The word can be constructed from letters of sequentially adjacent cell, where “adjacent” cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>board =<br>[<br>  [‘A’,’B’,’C’,’E’],<br>  [‘S’,’F’,’C’,’S’],<br>  [‘A’,’D’,’E’,’E’]<br>]  </p></blockquote><blockquote><p>Given word = “ABCCED”, return true.<br>Given word = “SEE”, return true.<br>Given word = “ABCB”, return false.  </p></blockquote><pre><code>我的解法：（AC-beat77.88%，遇到了许多细节问题）很容易想到是一个DFS的过程，当遇到第一个可行的解，就直接return。但是，由于是字符串整体判断，不允许使用在本次DFS遍历中使用过的char。所以需要visit[][]矩阵来标记本次dfs所经过的点。这里蛋疼的是visit[][]其实是一个对象，在传给不同遍历方向DFS时是实参，牵一发而动全身。就算用clone方法、new新的，只要做=的操作，就是一份相同的对象。但是，DFS虽然是一个多个方向全部发展的形式，他还是每次只有一个支线走到最深。也就意味着最多一个DFS支线在修改。而DFS又是一个入栈出栈的方式，那么我只要在入栈的时候标记true，出栈的时候标记回false不就可以重复利用了！而且一旦找到一个可行解，直接return其他都不需要在管了。实现细节plus1，在不同方向的DFS选择，用一个全局的directions数组循环来判断就好了。这样可以节省判断次数。实现细节plus2，递归方法的设计。将所有溢出边界、找到解、遍历到了已遍历过坐标、char不匹配等退出递归的标志。全部加载方法的开始，方法的体只需要将所有可能情况尽情递归即可。</code></pre><h3 id="2018-5-7-Submission-Detail-Medium"><a href="#2018-5-7-Submission-Detail-Medium" class="headerlink" title="2018.5.7-Submission Detail-Medium"></a>2018.5.7-Submission Detail-Medium</h3><p><strong>原地dp</strong>，不难，但是一开始只beat16%，正答里<strong>直接使用原矩阵空间做动态规划</strong>，beat85%，也算是新颖的动态规划解法了。</p><h3 id="2018-5-7-Insert-Delete-GetRandom-O-1-Medium"><a href="#2018-5-7-Insert-Delete-GetRandom-O-1-Medium" class="headerlink" title="2018.5.7-Insert Delete GetRandom O(1)-Medium"></a>2018.5.7-Insert Delete GetRandom O(1)-Medium</h3><p><strong>map+arraylist+random</strong>，也不难，但是要注意边界条件，用到了Math.random()方法（输出0~1的double随机数）。</p><h2 id="2018-5-7-Find-All-Duplicates-in-an-Array-Medium"><a href="#2018-5-7-Find-All-Duplicates-in-an-Array-Medium" class="headerlink" title="2018.5.7-Find All Duplicates in an Array-Medium"></a>2018.5.7-Find All Duplicates in an Array-Medium</h2><p><strong>原地空间判断重复</strong>  </p><blockquote><p>Given an array of integers, 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p></blockquote><blockquote><p>Find all the elements that appear twice in this array.</p></blockquote><blockquote><p>Could you do it without extra space and in O(n) runtime?<br>Input:<br>[4,3,2,7,8,2,3,1]<br>Output:<br>[2,3]  </p></blockquote><pre><code>我的解法：（AC-beat38%）比较巧解的题，由于要求O(N)时间O(1)空间。那就必须原地判断好，好在数的范围已经是1~n了。那么就循环遍历元素，将arr[i]值理解为下标，该下标的数就算出现了一次。对该下标的值乘-1。检查该下标值，如果负数，代表刚刚处理了一次，也就是arr[i]第一次出现在数组。如果是正数，就代表这是第二次处理了，直接加入结果集。</code></pre><h2 id="2018-5-8-Rotate-Image-Medium"><a href="#2018-5-8-Rotate-Image-Medium" class="headerlink" title="2018.5.8-Rotate Image-Medium"></a>2018.5.8-Rotate Image-Medium</h2><p><strong>原地旋转矩阵</strong>  </p><blockquote><p>对给出矩阵顺时针旋转90度，要求不能声明新的矩阵。</p></blockquote><pre><code>我的解法：（AC-beat100%）其实找找规律就知道了。先每个第i行和倒数第i行对换位置。再第i行和第i列对换位置。也就是a[i][j]和a[j][i]对换。想直接找一个公式一步到位也不是不可以，但是太麻烦了。不是解题应该有的思维。</code></pre><h2 id="2018-5-8-Maximum-Length-of-Repeated-Subarray-Medium"><a href="#2018-5-8-Maximum-Length-of-Repeated-Subarray-Medium" class="headerlink" title="2018.5.8-Maximum Length of Repeated Subarray-Medium"></a>2018.5.8-Maximum Length of Repeated Subarray-Medium</h2><p><strong>二维dp</strong>，不难  </p><blockquote><p>Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.<br>Input:<br>A: [1,2,3,2,1]<br>B: [3,2,1,4,7]<br>Output: 3<br>The repeated subarray with maximum length is [3, 2, 1].  </p></blockquote><pre><code>我的解法：（AC-beat88.43%）二维dp，dp[i][j]代表A以i结尾的子串中，对应B以j结尾的子串中，最长公共子串长度。公共子串必须以i、j结尾。一直所有dp[i][0]，dp[0][j]。dp[i][j] = A[i] == B[j] ? dp[i-1][j-1] + 1 : 0;</code></pre><h2 id="2018-5-8-Combination-Sum-Medium–👍"><a href="#2018-5-8-Combination-Sum-Medium–👍" class="headerlink" title="2018.5.8-Combination Sum-Medium–👍"></a>2018.5.8-Combination Sum-Medium–👍</h2><p><strong>dfs、回溯</strong>，不错的一道题，经典DFS  </p><blockquote><p>给出不重复的正整数数组作为备选数，给出target，使用备选数找到所有不重复组合的sum为target。返回组合。<br>所有备选都可以重复使用。<br>Input: candidates = [2,3,5], target = 8,<br>A solution set is:<br>[<br>  [2,2,2,2],<br>  [2,3,3],<br>  [3,5]<br>]  </p></blockquote><pre><code>我的解法：（AC-beat86.67%）为了不出现重复答案，先把备选数组排序，这样顺序按顺序选择备选组合元素就不会重复了。以DFS的形式，递归传递int[] can, int tar, int pos, List&lt;Integer&gt; one, int sum（备选集合、目标大小、当前选择位置、路径、当前和）做好退出判断、冗余排除、添加答案。</code></pre><ul><li><strong>全局变量</strong>：将答案<code>List&lt;List&lt;Integer&gt;&gt;</code>、备选集合长度保存在全局变量，避免递归传递。</li><li><strong>递归方法设计</strong>：方法入口设置退出判断，方法出口尽情递归。</li><li><strong>结果保存</strong>：由于使用<code>List&lt;Integer&gt;</code>保存路径，属于实参前已发动全身，所以需要每次保存结果都要新声明一个<code>List&lt;Integer&gt;</code>将路径元素一个个放入。</li><li><strong>冗余排除</strong>：由于备选数组已排序，所以当达成<code>sum&gt;target</code>的退出条件，当下dfs的后续备选都不需要去考虑了，给递归方法设计为boolean返回型，辅助判断即可。</li></ul><h2 id="2018-5-8-My-Calendar-I-Medium—👍"><a href="#2018-5-8-My-Calendar-I-Medium—👍" class="headerlink" title="2018.5.8-My Calendar I-Medium—👍"></a>2018.5.8-My Calendar I-Medium—👍</h2><p><strong>区间二分查找，时间段交叉验证</strong>，边缘情况蛮麻烦的一道题。。。  </p><blockquote><p>实现一个Calendar类，包括book方法，传入一个时间段start、end，如果和已有的时间段都没有交叉，则加入到时间段，返回true，否则返回false。<br>MyCalendar();<br>MyCalendar.book(10, 20); // returns true<br>MyCalendar.book(15, 25); // returns false<br>MyCalendar.book(20, 30); // returns true  </p></blockquote><pre><code>我的解法：（AC-beat92%）无非是两部分，查询、添加。用一个数组保存所有start、end，凡是合理的时间段肯定其start、end是相邻的。查询用二分查找，找到a[i]&lt;x &amp;&amp; a[i+1]&gt;=x的情况，i+1就是其应该插入的位置。查询待插入的start的应该插入位置，如果是奇数位置必然不可以。再有a[i+1]&gt;=end就可以插入。其中要判断空数组、头尾边缘位置的边缘检查。</code></pre><p>我的做法有些追求时间复杂度了，但是说实话插入操作如果已经O(N)了，何必费劲去用O(logN)取查找呢= =。。。真蠢    </p><h2 id="2018-5-9-Task-Scheduler-Medium—👍"><a href="#2018-5-9-Task-Scheduler-Medium—👍" class="headerlink" title="2018.5.9-Task Scheduler-Medium—👍"></a>2018.5.9-Task Scheduler-Medium—👍</h2><p><strong>贪心，巧妙理解，cpu task队列</strong>，尽管有点微妙难想，但是还是不错的题。  </p><blockquote><p>给出由最多26个大写字母表示的task，相同字母代表相同任务，给定n代表两个相同的任务最起码要隔多少个idle或其他任务来执行。<br>求出完成所有任务最起码需要的时间。<br>Input: tasks = [“A”,”A”,”A”,”B”,”B”,”B”], n = 2<br>Output: 8<br>Explanation: A -&gt; B -&gt; idle -&gt; A -&gt; B -&gt; idle -&gt; A -&gt; B.  </p></blockquote><pre><code>我的解法：（过于愚蠢和麻烦，写不出来）首先需要得到所有任务的个数，因为最多26个字母，直接用int[]统计一下就好了。对各个任务数量做Arrays.sort。由于限定了间隔n，也就意味着要n+1个任务一组一起执行，n+1个任务里不能有重复任务。也就是说将所有相同任务的任务数作为目标，全都用上。求出来n+1个和，让最大的那个和最小即可。这特么不是NP难问题吗？提示解法：（AC-beat81.81%）其实题意根本就没理解对，是要求了，相同的任务必须隔n个时间才能执行。但是，我隔n+1个可以执行吗？我隔更多个可以吗？我隔的一定是个固定的数吗？我的想法太绑定那个时间间隔了。谁说非要n+1个一组了。如果我可以保证不同的任务有多于n+1个，不也可以执行吗？正确的理解应该是贪心的。不用sort，用一个局部变量max和count统计最多的相同任务有多少个，一样多的任务有多少种。用int[26]保存每个任务的数量，在对task[]的遍历时更新int[26]、max、count。知道最多的任务了，也就知道要达到n的间隔，最起码要用多少个时间了。比如AAADDEJJBBBBCCCC n=2，最起码要BC_ BC_ BC_ BC个时间对吧。那我剩下的任务呢，这里注意，每个_不是一个位置，我可以插至少一个。所以其实剩下的任务数，只要不少于目前空的数量，那就一定可以插满，也就意味着用len的时间间隔就够了。如果少于目前空的数量，那就代表一定有空，算一下就好了。</code></pre><h3 id="2018-5-9-Unique-Paths-Medium"><a href="#2018-5-9-Unique-Paths-Medium" class="headerlink" title="2018.5.9-Unique Paths-Medium"></a>2018.5.9-Unique Paths-Medium</h3><p><strong>dp、组合计算</strong>，easy</p><h2 id="2018-5-9-Submission-Detail-Medium"><a href="#2018-5-9-Submission-Detail-Medium" class="headerlink" title="2018.5.9-Submission Detail-Medium"></a>2018.5.9-Submission Detail-Medium</h2><p><strong>dfs，回溯</strong>，不难，但是要考虑清楚时间复杂度。  </p><blockquote><p>给定一个不重复数组，给出由数组中所有元素组成的可能子数组，不难重复出现。<br>Input: nums = [1,2,3]<br>Output:<br>[<br>  [3],<br>  [1],<br>  [2],<br>  [1,2,3],<br>  [1,3],<br>  [2,3],<br>  [1,2],<br>  []<br>]  </p></blockquote><pre><code>我的解法1：（超时）最简单直接的理解，一共有2^n种可能。每个数由用、不用两种可能。直接从0不断++到2^n-1。分别用当前数二进制中为1的位置对应的nums中数字组成子数组。时间复杂度O(2^N*N)。2^n都出来了，你觉得不超时会上天啊？我的解法2：（AC-beat100%）用dfs遍历所有可能，因为解法1中由答案[1]到答案[1,2]其实是有关系的，所以相当于冗余。dfs(nums, pos+1, path);path.add(nums[pos]);dfs(nums, pos+1, path);path.remove(path.size()-1);懂了吧</code></pre><h2 id="2018-5-10-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee-Medium—👍"><a href="#2018-5-10-Best-Time-to-Buy-and-Sell-Stock-with-Transaction-Fee-Medium—👍" class="headerlink" title="2018.5.10-Best Time to Buy and Sell Stock with Transaction Fee-Medium—👍"></a>2018.5.10-Best Time to Buy and Sell Stock with Transaction Fee-Medium—👍</h2><p><strong>dp，贪心，题意理解</strong>，很不错的一道动态规划题，需要很好的理解题意找到关键点才能设计好代码。  </p><blockquote><p>给出一个数组，第i位数即第i天股票的价格，同时只能持有一个股票，每次卖出股票都需要fee的手续费，求出最大收益。<br>Input: prices = [1, 3, 2, 8, 4, 9], fee = 2<br>Output: 8<br>Explanation: The maximum profit can be achieved by:<br>Buying at prices[0] = 1<br>Selling at prices[3] = 8<br>Buying at prices[4] = 4<br>Selling at prices[5] = 9<br>The total profit is ((8 - 1) - 2) + ((9 - 4) - 2) = 8.  </p></blockquote><pre><code>我的解法：（AC-beat60%）（写的过程出了些细节错误）多考察几个例子就能理解了。1 4 5 8 4 9，2   1buy 4sell 5buy 6sell1 4 2 8 4 9，1    1buy 2sell 3buy 4sell 5buy 6sell1 5 3 8 4 9，3    1buy 4sell 5buy 6sell &gt; 1buy 2sell 3buy 4sell 5buy 6sell其实就是要保存目前最低的股票价格dp[i]以及从最低股票价格之后的最高股票价格max但是这里面存在一个手续fee，也就意味着想要卖股票先得保证能赚钱，且能赚最多的钱而且，当prices[i]&lt;max的时候，也不一定应该卖    如果max - prices[i] &lt;= fee的话，那我本次卖了，万一之后最小就是prices[i]，再卖一次，就会手续费亏钱。不如到最后最高点再卖。    如果max - prices[i] &gt; fee，那这次一定要卖，之后就算再交一次手续费，也不会亏。此时dp[i]，max都更新为prices[i]。从原理上讲，就是价格波动的时候，允许回调一定程度，而不是立马卖了再买，因为要计入手续费的成本。细节：注意max是保存从dp[i]保存的那个元素之后的max，毕竟不能跑到以前去卖。</code></pre><h2 id="2018-5-14-Product-of-Array-Except-Self-Medium"><a href="#2018-5-14-Product-of-Array-Except-Self-Medium" class="headerlink" title="2018.5.14-Product of Array Except Self-Medium"></a>2018.5.14-Product of Array Except Self-Medium</h2><p><strong>dp，问题分解</strong>，不难，但是要注意边缘情况以及最大节省时间、空间。</p><blockquote><p>给出一个数组，返回一个数组，使每个元素都是原数组该位置其他所有元素的积。<br>Input:  [1,2,3,4]<br>Output: [24,12,8,6]<br>要求：时间O(N)，空间O(1)，不能用除法。</p></blockquote><pre><code>我的解法：（AC-beat99.84%）不能使用除法，就不能用最简单的做法计算所有数的积再一一做除。但是发现每个位置的数对应结果，就是其他所有数的积。也就是自己前面所有数的积*自己后面所有数的积。那么就可以拆分成计算两次动态规划，分别是前i个数的积和后i个数的积。时间复杂度O(N)。但是其实如果把两个过程割裂不一起计算，用一个局部变量就可以实现，没必要保存所有结果，那么空间就是O(1)。如：nums[1,2,3,4]  res[1,1,1,1]    前i积dp：res[1,1,2,6]    后i积dp：res[24,12,8,6]PS：如果nums中存在0，那么其他所有数的结果都是0，除了自己，需要注意处理。</code></pre><h2 id="2018-5-14-Maximum-Product-Subarray-Medium"><a href="#2018-5-14-Maximum-Product-Subarray-Medium" class="headerlink" title="2018.5.14-Maximum Product Subarray-Medium"></a>2018.5.14-Maximum Product Subarray-Medium</h2><p><strong>dp，节省空间</strong>，不难，但是为了节省空间我没有用数组而是用O(1)空间，边界条件判断比较麻烦。  </p><blockquote><p>给一个整数数组，返回由连续子数组连乘的最大乘积。<br>Input: [2,3,-2,4]<br>Output: 6<br>Explanation: [2,3] has the largest product 6.<br>Input: [-2,0,-1]<br>Output: 0<br>Explanation: The result cannot be 2, because [-2,-1] is not a subarray.</p></blockquote><pre><code>我的解法：（AC-beat99.14%）首先由于全是整数，所以不用考虑小数使变小，所以只要乘以一个正数，肯定是比之前不小的。这里面需要小心的就是存在负数。尽管当前可能是个负数，但是可能存在之后还有负数可以达到更大的正数。所以需要两个遍历，保存当前以i结尾的子数组中，乘积最大、最小的正数和负数。保存负数来保留负负得正的可能性。</code></pre><h2 id="2018-5-15-Subarray-Sum-Equals-K-Medium—正答很棒👍"><a href="#2018-5-15-Subarray-Sum-Equals-K-Medium—正答很棒👍" class="headerlink" title="2018.5.15-Subarray Sum Equals K-Medium—正答很棒👍"></a>2018.5.15-Subarray Sum Equals K-Medium—正答很棒👍</h2><p><strong>二维dp转变为一维dp、O(N)找子数组和</strong>，要节省空间</p><blockquote><p>给一个数组，找到所有连续子数组的和为k的子数组数量。<br>Input:nums = [1,1,1], k = 2<br>Output: 2    </p></blockquote><pre><code>我的解法：（AC-beat6.8%）首先数组是无序的有正有负，那无法用比较快的窗口遍历的方式。既然是连续子数组，必然可以转化为子问题。所以用dp[i][j]代表第i到第j的子数组和（i&gt;=j）。但是空间不够了。由于dp[i][j] = dp[i-1][j] - nums[i-1]，所以其实每一行都是上一行结果对应得到的，那么就可以用一维数组记录每一行结果了。动态记录所有和为k的。时间O(N^2)。才beat6.8%。。能感觉到有很多冗余计算。正答：很棒的想法（AC-beat82.86%）首先不需要考虑二维动态规划，因为dp[i][j] = dp[0][j] - dp[0][i]。没想到吧，类似于求矩阵子矩阵和的方式，那么二维动态规划就能转变为一维。只存储dp[i].另外，寻找一个连续子数组和为精准值k，也不需要去算dp[j] - dp[i]。如果把每一个dp[j]都存在map里，那么用2sum的解法，不就可以不断寻找k-dp[i]是否存在不就好了？时间O(N)。</code></pre><h2 id="2018-5-15-Subsets-II-Medium"><a href="#2018-5-15-Subsets-II-Medium" class="headerlink" title="2018.5.15-Subsets II-Medium"></a>2018.5.15-Subsets II-Medium</h2><p><strong>dfs</strong>，不难，需要想一下细节。<br>记住这句代码：<code>res.add(new ArrayList&lt;&gt;(path));</code>，不要去循环遍历path加入到新的List里。  </p><blockquote><p>给一个数组，数组中会有重复元素，返回所有不重复的子数组集合。<br>Input: [1,2,2]<br>Output:<br>[<br>  [2],<br>  [1],<br>  [1,2,2],<br>  [2,2],<br>  [1,2],<br>  []<br>]  </p></blockquote><pre><code>我的解法：（AC-beat90%）由于数组是未排序的，且存在相同的元素，就存在多个相同元素应该用哪个不用哪个，还会出现重复情况。所以先排序，保证相同元素相邻。然后顺序执行dfs，每层迭代分为是否加入i元素。如果遇到之后元素相同，就把所有相同元素加入到path。</code></pre><h2 id="2018-5-15-Find-the-Duplicate-Number-Medium—巧妙理解题意👍"><a href="#2018-5-15-Find-the-Duplicate-Number-Medium—巧妙理解题意👍" class="headerlink" title="2018.5.15-Find the Duplicate Number-Medium—巧妙理解题意👍"></a>2018.5.15-Find the Duplicate Number-Medium—巧妙理解题意👍</h2><p><strong>问题转化，带环链表找到环的起点</strong>，也可以用二分查找。</p><blockquote><p>给定长度为n+1的数组，内含有1~n的数，只有一个数是重复出现两次的，其他都出现一次。找出这个数。<br>要求：时间&lt;O(N^2)，空间O(1)，不允许编辑数组。<br>Input: [1,3,4,2,2]<br>Output: 2  </p></blockquote><pre><code>我的解法：（AC-beat99.34%）O(N)不允许编辑数组那么不许排序，数组保持打乱状态。空间O(1)代表不能新建数组。但是可以注意到，数的范围是1~n，正好各出现了一次，只有一个是重复两次的。那么如果把数组每一个元素都看作链表的结点，nums[i]代表第i个结点指向的下一个结点。PS：遍历过程中不会出现自己指向自己。    因为首先启动项下标为0，也就意味着不会有其他结点指向这个结点，0号结点也只能指向别人。    一旦有指向自己的结点，就不可能被别人遍历到，因为每个结点只出现一次，除非是重复的对吗。以 [1,3,4,2,2]  为例，就是3-&gt;2-&gt;4-&gt;2-&gt;4..的链表。可以看到从2开始就是环了，多几个例子可以总结出来：一旦有重复元素，这个链表从重复的那个元素开始就会变成环。那么问题就转变成了找到一个链表的环的起点。先是一个fast（一次迈两步），一个slow（一次迈一步）直到相遇。再两个slow从起点和上一步交点开始，相遇点就是环起点，也就是重复元素。其他解法：O(NlogN)二分查找思想，不断选定mid。遍历所有元素统计小于、大于等于mid的元素数。其中一部分必定比正常多一个，那么重新设定low、high缩小范围。</code></pre><h2 id="2018-5-15-Combination-Sum-II-Medium—👍可以再回头看看细节处理"><a href="#2018-5-15-Combination-Sum-II-Medium—👍可以再回头看看细节处理" class="headerlink" title="2018.5.15-Combination Sum II-Medium—👍可以再回头看看细节处理"></a>2018.5.15-Combination Sum II-Medium—👍可以再回头看看细节处理</h2><p><strong>01背包，回溯，要保证连续相同元素构成子数组并dfs的时候不重复</strong></p><blockquote><p>给定一个数组，会存在重复元素，一个target，找到所有子数组，使子数组的和为target。<br>数组中每个元素不允许重复使用。结果子数组不能重复。<br>Input: candidates = [10,1,2,7,6,1,5], target = 8,<br>A solution set is:<br>[<br>  [1, 7],<br>  [1, 2, 5],<br>  [2, 6],<br>  [1, 1, 6]<br>]  </p></blockquote><pre><code>我的做法：（AC-beat21.6 %，但是比较好的也没什么大差别，自己写的更好理解一些。）首先有重复元素，就要保证重复元素构成子数组不出现重复情况。先要排序，保证所有相同元素都在一起。其他没什么特别的，就是dfs的回溯过程。但是当遇到连续的重复元素，面临选还是不选的dfs方向。如果选，那就之后相同的全都选。如果不选，那就走下一个元素。这样可以保证不出现101，011，110这种其实是重复的11的情况。（但是，由于要凑出来总的target，所以连续的不断选相同结果，可能导致早就高于target做了冗余添加删除）</code></pre><h2 id="2018-5-16-Triangle-Medium"><a href="#2018-5-16-Triangle-Medium" class="headerlink" title="2018.5.16-Triangle-Medium"></a>2018.5.16-Triangle-Medium</h2><p><strong>dp降维</strong>，不难，将二维dp简化为一维，将两个临时一维数组简化为一个一维数组。</p><blockquote><p>给定一个金字塔形的二维list，找到从第一行到最后一行的sum最小路径，返回sum。<br>要求空间小于O(N)。<br>[<br>……[2],<br>…..[3,4],<br>…[6,5,7],<br>..[4,1,8,3]<br>]<br>2 + 3 + 5 + 1 = 11</p></blockquote><pre><code>我的解法：（AC-beat94.3%）由于限制了空间，就不能用二维dp，但是由于是一行一行的。每一行的每个结果都对应上一行一个/两个元素。那么只需要两个临时一位数组保存两行的dp即可。dp2[j] = Math.min(dp1[j], dp1[j-1]) + nums.get(i).get(j);其他做法（优化）：为什么需要两个一维数组？因为在从上到下更新的时候，不能简单地把dp1的元素修改，在第二行的后面元素还要用前面的结果。但是如果我从下往上走呢？同样是找最小路径，从上到下还是从下到上都一样，但是从下到上就允许修改dp1了，这样就只需要一个一维数组来dp了。</code></pre><h2 id="2018-5-16-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium—👍面试真题"><a href="#2018-5-16-Construct-Binary-Tree-from-Preorder-and-Inorder-Traversal-Medium—👍面试真题" class="headerlink" title="2018.5.16-Construct Binary Tree from Preorder and Inorder Traversal-Medium—👍面试真题"></a>2018.5.16-Construct Binary Tree from Preorder and Inorder Traversal-Medium—👍面试真题</h2><p><strong>二叉树，递归，遍历</strong>，需要理清关系、边界。</p><blockquote><p>给两个数组，代表一个二叉树先序、中序两个遍历顺序的各个结点的值。返回原树结构。<br>preorder = [3,9,20,15,7]<br>inorder = [9,3,15,20,7]<br>    …3<br>   ../ \<br>  .9  20<br>    ./  \<br>   15   7  </p></blockquote><pre><code>我的解法：（AC-beat39.34%）貌似也没什么值得优化的地方了。（更快的办法是用栈来代替递归）先序遍历可以确定一颗子树的根结点。中序遍历可以根据根结点找到其左右子树范围。而且先序遍历的根结点紧跟着的就是左孩子。再经过左子树的结点数，第一个就是右孩子。不难，需要考虑清楚细节及边界情况。</code></pre><h2 id="2018-5-24-Number-of-Matching-Subsequences-Medium—👍👍（正答很优秀）"><a href="#2018-5-24-Number-of-Matching-Subsequences-Medium—👍👍（正答很优秀）" class="headerlink" title="2018.5.24-Number of Matching Subsequences-Medium—👍👍（正答很优秀）"></a>2018.5.24-Number of Matching Subsequences-Medium—👍👍（正答很优秀）</h2><p><strong>大规模测试用例，节省空间、时间，贪心</strong>，一些节省空间、时间的窍门。算是最近写到的最多代码的题了。</p><blockquote><p>提供一个原str全是小写字母，提供一个str[]，考察这个数组中有多少个可以由原字符串子序列得到。<br>原字符串每个字母只用一次，子序列不能破坏原字符串字母间先后关系。<br>Input:<br>S = “abcde”<br>words = [“a”, “bb”, “acd”, “ace”]<br>Output: 3<br>Explanation: There are three words in words that are a subsequence of S: “a”, “acd”, “ace”.  （如果是ba就不行）</p></blockquote><pre><code>我的做法：（AC-beat70%）首先尝试了遍历每一个word数组，分别用O(N)遍历原S所有字母，知道某个字母找不到。但是明显复杂度太高了，一旦word数组的长度很大，就算word每个字符串很小，也要都遍历S一次。而且可以注意到其中相同的字母会出现大量的冗余计算。题目给出了，全是小写字母，也就意味着，不管S多大，最多26种元素。那么就可以只遍历一遍S，每个字母准备一个list，保存所有该字母出现位置。再依次遍历words，用临时变量min保存当前word当前字母的最小可行位置，这个位置也是下一个字母不能小于的位置。（这样保证去除冗余计算，保证字母间相关关系）特别的是，在查找一个字母不小于一个位置的出现位置时，用二分查找可以节省时间。O(n+mlogn)其他正答：（AC-beat74% 非常有意思更直观的做法）首先每个word可以用一种时间序列的方式来看待。一共26个字母，每个对应一个准备队列，代表正在等待这个字母再次出现的word有哪些，分别处于哪个位置。当然初始化就是每个word加入到第一个字母的准备队列。然后依次遍历S，遍历到的每个字母，都代表这个字母的准备队列都就绪了。这个字母的准备队列每一个word都加入到后移一位的字母的准备队列中，代表去等待下一个字母的出现。这样，类似于一个并行的过程，只需要遍历一遍S就完了。最好O(n)，但是最坏可以到O(m*n)。</code></pre><h3 id="2018-5-24-Search-a-2D-Matrix-Medium"><a href="#2018-5-24-Search-a-2D-Matrix-Medium" class="headerlink" title="2018.5.24-Search a 2D Matrix-Medium"></a>2018.5.24-Search a 2D Matrix-Medium</h3><p><strong>二分查找</strong>，由于矩阵是每一行排序，第二行最小比第一行最大还大，所不难，先对行二分查找，再对列二分查找。beat95.25%。</p><h2 id="2018-5-24-Maximum-Swap-Medium—👍（很多细节）"><a href="#2018-5-24-Maximum-Swap-Medium—👍（很多细节）" class="headerlink" title="2018.5.24-Maximum Swap-Medium—👍（很多细节）"></a>2018.5.24-Maximum Swap-Medium—👍（很多细节）</h2><p><strong>数字每一位处理，但是要尝试足够的测试用例，排序的优化</strong>，题的原理上不难，但是细节太麻烦。</p><blockquote><p>给定一个正整数，返回经过一次swap得到的最大正整数。<br>Input: 2736<br>Output: 7236</p></blockquote><pre><code>我的解法：（AC-beat67%）很好想到，显示要每一位都取出来，存到int[]。但是要存两个，其中一个排序。所要swap的那个数一定是已排序未排序两个数组中高位开始第一个不一样的数。那么被swap的那个数就是原数组这个位置的数。要swap的数是原数组最后一次出现的这个数。才能保证最大。如：109090901，最大一定是909090101被换的一定是9和1，但是有很多个9，保证最大必须换最后一个。O(NlogN)，受限于排序。最快的将int转成一位一位的：char[] digits = Integer.toString(num).toCharArray();Integer.valueOf(new String(digits));正答：O(N)由于以上解法受限于排序的时间复杂度。而这道题的情况在于取出一个正整数的每一位，也就意味着0~9.也就意味着可以用桶排序。O(N)。</code></pre><h2 id="2018-5-25-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium"><a href="#2018-5-25-Construct-Binary-Tree-from-Inorder-and-Postorder-Traversal-Medium" class="headerlink" title="2018.5.25-Construct Binary Tree from Inorder and Postorder Traversal-Medium"></a>2018.5.25-Construct Binary Tree from Inorder and Postorder Traversal-Medium</h2><p><strong>根据中序、后序遍历还原二叉树</strong>，不难</p><blockquote><p>inorder = [9,3,15,20,7]<br>postorder = [9,15,7,20,3]<br>—   3<br>—  / \<br>–  9  20<br>–    /  \  </p><ul><li>15   7  </li></ul></blockquote><pre><code>我的解法：（AC-beat40%）不断获得左子树和右子树，递归构造子树根结点及其左子树右子树即可。分别确定左子树的结点和右子树的结点分别在中序、后序哪个子序列中。（子树所有结点一定是连续的）根结点一定是对应后序序列的最后一个。其他解法：（AC-beat90%）一般做法慢就慢在递归过程上。所以用一个栈模拟这个过程就会比直接递归更快，但是貌似没有太大意义。不太想去仔细搞懂= =。</code></pre><h2 id="2018-5-25-Majority-Element-II-Medium—-👍"><a href="#2018-5-25-Majority-Element-II-Medium—-👍" class="headerlink" title="2018.5.25-Majority Element II-Medium—-👍"></a>2018.5.25-Majority Element II-Medium—-👍</h2><p><strong>数组中出现比例大于1/k的数，Moore’s voting Algorithm</strong>，需要充分理解结题方法。</p><blockquote><p>给一个数组，找到其中出现比例大于1/3的所有数。<br>Input: [1,1,1,3,3,2,2,2]<br>Output: [1,2]</p></blockquote><pre><code>我的解法：（AC-beat100%）Moore&apos;s voting Algorithm，就不多解释了，在《一些需要记得题》章节里有详细说明。由于这里限制了k=3，所以只需要两个counter，考虑些特别情况就好了。</code></pre><h2 id="2018-5-25-Jump-Game-Medium"><a href="#2018-5-25-Jump-Game-Medium" class="headerlink" title="2018.5.25-Jump Game-Medium"></a>2018.5.25-Jump Game-Medium</h2><p><strong>类似于dp</strong>，不难</p><blockquote><p>给定一个数组，每一个元素代表在这个位置最大可以跳多远，也可以跳那么大以内。检查是否可以一步步跳到最后一个位置。<br>nput: [2,3,1,1,4]<br>Output: true<br>Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.  </p></blockquote><pre><code>我的解法：（AC-beat2/3）O(N)，顺序遍历所有元素，保存一个low、一个high。low代表遍历进度，high代表目前能达到的最远是多少。当low超过high，说明无法达到high以后了。当high超过或等于最后一个位置，说明可以达到。</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Array&quot;&gt;&lt;a href=&quot;#Array&quot; class=&quot;headerlink&quot; title=&quot;Array&quot;&gt;&lt;/a&gt;Array&lt;/h1&gt;&lt;p&gt;很暴力的做法回溯也是很常见的做法。&lt;/p&gt;
&lt;h2 id=&quot;2018-4-1-Maximum-Product-of-Three-Numbers-Medium&quot;&gt;&lt;a href=&quot;#2018-4-1-Maximum-Product-of-Three-Numbers-Medium&quot; class=&quot;headerlink&quot; title=&quot;2018.4.1-Maximum Product of Three Numbers-Medium&quot;&gt;&lt;/a&gt;2018.4.1-Maximum Product of Three Numbers-Medium&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;多局部标记&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从一个数组中找到三个数，使其乘积max。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt;我的做法：
    用堆排序，得到正数的前三个，负数的后两个。
    但是你怎么知道建立多大的堆呢？
    一旦遍历得到大小，那就意味着失去了堆排序的优势了。
    但是必须得得到大小啊。。所以错。

正答：
    遍历一遍就可以了。不断更新五个临时变量。
    但是注意，初始化是Integer.MAX/MIN_VALUE，否则无法分辨全是负数的情况。
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="blog.lovelaolao.xin/categories/Algorithm/"/>
    
      <category term="Array" scheme="blog.lovelaolao.xin/categories/Algorithm/Array/"/>
    
      <category term="Medium" scheme="blog.lovelaolao.xin/categories/Algorithm/Array/Medium/"/>
    
    
      <category term="Array" scheme="blog.lovelaolao.xin/tags/Array/"/>
    
      <category term="Leetcode" scheme="blog.lovelaolao.xin/tags/Leetcode/"/>
    
      <category term="Medium" scheme="blog.lovelaolao.xin/tags/Medium/"/>
    
  </entry>
  
  <entry>
    <title>Leetcode689.Maximum Sum of 3 Non-Overlapping Subarrays-Hard</title>
    <link href="blog.lovelaolao.xin/Algorithm/Array/Hard/leetcode689/"/>
    <id>blog.lovelaolao.xin/Algorithm/Array/Hard/leetcode689/</id>
    <published>2018-05-29T15:32:00.000Z</published>
    <updated>2018-05-29T15:38:39.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>DP、贪心，想清楚流程</strong></p><blockquote><p>给定一个正整数数组及每个子数组长度k，找到三个连续且不互相覆盖的子数组，使其和最大。返回三个子数组的起点位置。<br>若存在多个解，选序列最小的。<br>Input: [1,2,1,2,6,7,5,1], 2<br>Output: [0, 3, 5]<br>Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].<br>We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.</p></blockquote><p>可以说是非常非常绕的题了。。。做了好久好久，好在是靠自己做了出来。<br><a id="more"></a></p><h3 id="想法说明："><a href="#想法说明：" class="headerlink" title="想法说明："></a>想法说明：</h3><p>首先给出了限定找到<strong>3个</strong>不互相覆盖的连续子数组。这样就限制了问题的规模和所需的空间。<br>然后从例子的结果上看，这种题肯定可以用回溯判断所有三个子数组来找到最佳答案。相当于是穷举的做法，肯定没毛病，但是不用写就知道不管是在面试还是在leetcode上都是没办法通过的。  </p><p>明显这三个子数组是有先后顺序的，那么就可以尝试用DP来试试能不能分解出子问题。当然可以，但是是可以分解为两个维度上的子问题：<code>数组前i个数所能找到的最大和j个子数组</code>和<code>数组前i个数所能找到的最大和3、2、1个子数组</code>（这里注意必须保证划分的子问题最少有3*k个数）。</p><p>接下来就要考虑如何从比如<code>数组前i个数的最大和1个子数组</code>到<code>前i个数的最大和2个子数组</code>的升维。这里需要用到贪心。具体如下：</p><pre><code>我的解法：（AC-beat35%）准备一个数组dp[len][4]。dp[i][0]用于保存前i个数j个子数组的最大和是几。dp[i][1,2,3]分别保存前i个数的是三个子数组结果的起始位置。1. 一次dp：先求第一个所有连续k长度的子数组，并找到前i个数的最大连续子数组和及其起始点。（注意数的范围是0~len-2*k-1）2. 再求第二个所有连续k长度的子数组（数的范围是k~len-k-1），每个第二个连续k长度子数组都直接加上其起始位置之前所有数的最大和第一个连续k长度子数组（第一步已知）。    这样就得到了每个第二个连续k长度子数组所能得到的最大和的两个k长度子数组。3. 第二次dp：将所有的最大和两个连续k长度子数组的和，遍历一遍，得到前i个数的两个最大连续子数组和及其起始点。4. 再仿照进行一次第2、3步，就能得到前i个数的3个最大连续子数组和及其起始点。也就得到了结果。（进行第三次dp，数的范围是2*k~len-1）其实解法里存在一些空间、时间浪费，但是实在是不想去细细考察了。我在写的时候只是简单地复制了两次代码来求第二第三个子数组，当问题扩展了，完全可以设计一个递归函数来做。</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line">附代码：这是我写的最多字的leetcode的了= =。</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] maxSumOfThreeSubarrays(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">int</span> len = nums.length;</span><br><span class="line">        <span class="keyword">if</span>(len &lt; k*<span class="number">3</span>) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">if</span>(len == k*<span class="number">3</span>) &#123;</span><br><span class="line">            res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            res[<span class="number">1</span>] = k;</span><br><span class="line">            res[<span class="number">2</span>] = <span class="number">2</span>*k;</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[len][<span class="number">4</span>];<span class="comment">//dp[1,2,3]分别是其最大值第1，2，3段所在起点</span></span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>, max = <span class="number">0</span>, pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;k; i++) sum+=nums[i];</span><br><span class="line">        dp[k-<span class="number">1</span>][<span class="number">0</span>] = sum;</span><br><span class="line">        dp[k-<span class="number">1</span>][<span class="number">1</span>] = pos;</span><br><span class="line">        max = sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i&lt;len-<span class="number">2</span>*k; i++)&#123;</span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(sum &gt; max)&#123;</span><br><span class="line">                max = sum;</span><br><span class="line">                pos = i-k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max;</span><br><span class="line">            dp[i][<span class="number">1</span>] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        pos = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = k; i&lt;<span class="number">2</span>*k; i++) sum+=nums[i];</span><br><span class="line">        dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">2</span>] = sum+dp[k-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i&lt;len-k; i++)&#123;</span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            dp[i][<span class="number">2</span>] = sum+dp[i-k][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">2</span>] = pos;</span><br><span class="line">        max = dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i&lt;len-k; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">2</span>] &gt; max)&#123;</span><br><span class="line">                max = dp[i][<span class="number">2</span>];</span><br><span class="line">                pos = i-k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max;</span><br><span class="line">            dp[i][<span class="number">2</span>] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sum = <span class="number">0</span>;</span><br><span class="line">        pos = <span class="number">2</span>*k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>*k; i&lt;<span class="number">3</span>*k; i++) sum+=nums[i];</span><br><span class="line">        dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">3</span>] = sum+dp[<span class="number">2</span>*k-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>*k; i&lt;len; i++)&#123;</span><br><span class="line">            sum -= nums[i-k];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            dp[i][<span class="number">3</span>] = sum+dp[i-k][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">0</span>] = dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">3</span>] = pos;</span><br><span class="line">        max = dp[<span class="number">3</span>*k-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">3</span>*k; i&lt;len; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i][<span class="number">3</span>] &gt; max)&#123;</span><br><span class="line">                max = dp[i][<span class="number">3</span>];</span><br><span class="line">                pos = i-k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = max;</span><br><span class="line">            dp[i][<span class="number">3</span>] = pos;</span><br><span class="line">        &#125;</span><br><span class="line">            </span><br><span class="line">        res[<span class="number">2</span>] = dp[len-<span class="number">1</span>][<span class="number">3</span>];</span><br><span class="line">        res[<span class="number">1</span>] = dp[dp[len-<span class="number">1</span>][<span class="number">3</span>]-<span class="number">1</span>][<span class="number">2</span>];</span><br><span class="line">        res[<span class="number">0</span>] = dp[dp[dp[len-<span class="number">1</span>][<span class="number">3</span>]-<span class="number">1</span>][<span class="number">2</span>]-<span class="number">1</span>][<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;DP、贪心，想清楚流程&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;给定一个正整数数组及每个子数组长度k，找到三个连续且不互相覆盖的子数组，使其和最大。返回三个子数组的起点位置。&lt;br&gt;若存在多个解，选序列最小的。&lt;br&gt;Input: [1,2,1,2,6,7,5,1], 2&lt;br&gt;Output: [0, 3, 5]&lt;br&gt;Explanation: Subarrays [1, 2], [2, 6], [7, 5] correspond to the starting indices [0, 3, 5].&lt;br&gt;We could have also taken [2, 1], but an answer of [1, 3, 5] would be lexicographically larger.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;可以说是非常非常绕的题了。。。做了好久好久，好在是靠自己做了出来。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="blog.lovelaolao.xin/categories/Algorithm/"/>
    
      <category term="Array" scheme="blog.lovelaolao.xin/categories/Algorithm/Array/"/>
    
      <category term="Hard" scheme="blog.lovelaolao.xin/categories/Algorithm/Array/Hard/"/>
    
    
      <category term="Array" scheme="blog.lovelaolao.xin/tags/Array/"/>
    
      <category term="贪心" scheme="blog.lovelaolao.xin/tags/%E8%B4%AA%E5%BF%83/"/>
    
      <category term="DP" scheme="blog.lovelaolao.xin/tags/DP/"/>
    
      <category term="Leetcode" scheme="blog.lovelaolao.xin/tags/Leetcode/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next博客须知</title>
    <link href="blog.lovelaolao.xin/BuildBlog/Hexo-Next%E5%AE%9E%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>blog.lovelaolao.xin/BuildBlog/Hexo-Next实用技巧/</id>
    <published>2018-05-28T04:29:00.000Z</published>
    <updated>2018-05-28T08:19:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="博文密码"><a href="#博文密码" class="headerlink" title="博文密码"></a>博文密码</h2><p>在标题部分加password标识。就需要输入密码才能访问。但是还是可以在主页看到预览。</p><pre><code>如：title: Hexo-Next博客须知date: 2018/5/28 00:00:00password: test</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;博文密码&quot;&gt;&lt;a href=&quot;#博文密码&quot; class=&quot;headerlink&quot; title=&quot;博文密码&quot;&gt;&lt;/a&gt;博文密码&lt;/h2&gt;&lt;p&gt;在标题部分加password标识。就需要输入密码才能访问。但是还是可以在主页看到预览。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;如：

      
    
    </summary>
    
      <category term="BuildBlog" scheme="blog.lovelaolao.xin/categories/BuildBlog/"/>
    
    
      <category term="踩过的坑" scheme="blog.lovelaolao.xin/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>Hexo-Next博客须知</title>
    <link href="blog.lovelaolao.xin/BuildBlog/Hexo-Next%E5%8D%9A%E5%AE%A2%E9%A1%BB%E7%9F%A5/"/>
    <id>blog.lovelaolao.xin/BuildBlog/Hexo-Next博客须知/</id>
    <published>2018-05-26T00:52:00.000Z</published>
    <updated>2018-05-28T08:18:22.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="遇到问题怎么查"><a href="#遇到问题怎么查" class="headerlink" title="遇到问题怎么查"></a>遇到问题怎么查</h2><ul><li>遇到的所有问题都去官方git-release记录的问题里查。google也好，百度也好都不需要也不靠谱。</li><li>如果在配置文件中有和官方文档要求配置细节有不一致，以本地文件配置为准。因为官方文档没有跟上项目release。</li><li>配置文件中凡是注释掉的内容（如jiathis和百度分享），都是版本更新后已经淘汰掉的了，不用费神去取消注释尝试了。一般会有代替他们的存在，虽然在issue记录里不一定有。但是应该是可以用的，enable为true就好了。</li></ul><a id="more"></a><h2 id="代码高亮问题"><a href="#代码高亮问题" class="headerlink" title="代码高亮问题"></a>代码高亮问题</h2><ul><li>markdown里面代码块使用两个反三点包起来的，一般的md编译器都会显示高亮的，但是在next主题里面就不会，解决办法就是在第一个反三点的右边加上你所用的语言，例如java，C++，jsx等等 </li></ul><h2 id="md引用图片无法显示"><a href="#md引用图片无法显示" class="headerlink" title="md引用图片无法显示"></a>md引用图片无法显示</h2><ol><li>把主页配置文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为true </li><li>在你的hexo目录下执行这样一句话<code>npm install hexo-asset-image –save</code>，这是下载安装一个可以上传本地图片的插件 </li><li>等待一小段时间后，再运行<code>hexo n “xxxx”</code>来生成md博文时，<code>/source/_posts</code>文件夹内除了<code>xxxx.md</code>文件还有一个同名的文件夹 </li><li>最后在<code>xxxx.md</code>中想引入图片时，先把图片复制到<code>xxxx</code>这个文件夹中，然后只需要在<code>xxxx.md</code>中按照markdown的格式引入图片：<code>![你想输入的替代文字](xxxx/图片名.jpg)</code></li><li>最后检查一下，hexo g生成页面后，进入<code>public\2017\09\10\index.html</code>文件中查看相关字段，可以发现，html标签内的语句是<code>&lt;img src=&quot;2017/09/10/xxxx/图片名.jpg&quot;&gt;</code>，而不是<code>&lt;img src=&quot;xxxx/图片名.jpg&gt;</code>。这很重要，关乎你的网页是否可以真正加载你想插入的图片。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;遇到问题怎么查&quot;&gt;&lt;a href=&quot;#遇到问题怎么查&quot; class=&quot;headerlink&quot; title=&quot;遇到问题怎么查&quot;&gt;&lt;/a&gt;遇到问题怎么查&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;遇到的所有问题都去官方git-release记录的问题里查。google也好，百度也好都不需要也不靠谱。&lt;/li&gt;
&lt;li&gt;如果在配置文件中有和官方文档要求配置细节有不一致，以本地文件配置为准。因为官方文档没有跟上项目release。&lt;/li&gt;
&lt;li&gt;配置文件中凡是注释掉的内容（如jiathis和百度分享），都是版本更新后已经淘汰掉的了，不用费神去取消注释尝试了。一般会有代替他们的存在，虽然在issue记录里不一定有。但是应该是可以用的，enable为true就好了。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="BuildBlog" scheme="blog.lovelaolao.xin/categories/BuildBlog/"/>
    
    
      <category term="踩过的坑" scheme="blog.lovelaolao.xin/tags/%E8%B8%A9%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    
  </entry>
  
  <entry>
    <title>深度学习-思考题</title>
    <link href="blog.lovelaolao.xin/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/5.DL-%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83/"/>
    <id>blog.lovelaolao.xin/面经总结/5.DL-面试必考/</id>
    <published>2018-05-13T16:00:00.000Z</published>
    <updated>2018-07-25T13:41:38.000Z</updated>
    
    <content type="html"><![CDATA[<p><a name="1.0"></a></p><h2 id="深度学习（神经网络）发展史"><a href="#深度学习（神经网络）发展史" class="headerlink" title="深度学习（神经网络）发展史"></a>深度学习（神经网络）发展史</h2><p>深度学习=预测问题</p><p>1940s出现。1943 抽象的神经元模型MP。1949年心理学家Hebb提出了Hebb学习率，认为人脑神经细胞 上的连接强度上可以变化的。<br>1958-<strong>20世纪50年代 第一次兴起</strong> 感知机，单层神经元组成的神经网络。可以更改权重。（神经网络第一次浪潮）原理类似于svm的分类方式，当发现有分错的情况，调整权重。但是这是一个线性的分类器，只能分出简单的情况。<br>1969-<strong>20世纪60年代 第一次低谷</strong> Minsky 感知机被数学证明了局限性。OR/AND可以分类，但XOR异或决无法解决，除非将计算增加为两层，但是计算量过大，无法学习。进入了神经网络的寒冬。<br>1986-<strong>20世纪80年代 第二次兴起</strong> Rumelhar 和 Hintor等人提出了BP算法（链式法则），解决了两层神经网络所需要的复杂计算量。 1989年bell实验室用识别手写邮编在现实应用验证了BP的价值。但是BP慢、容易局部最优、太多参数、很难调参、难以得到稳定的结果。<br>1995年-<strong>20世纪90年代 第二次低谷</strong>，Vapnik等人提出了支持向量机(Support Vector Machines)算法，很快就在若干个方面体现出了对比神经网络的优势: 无需调参，高效，全局最优解。然后神经网络被吊打。1997年提出了LSTM，1998年提出LeNet网络。<br>2006，hinton提出深度信念网，通过预训练+微调使得在反向传播之前就有了一个很好的起点。且在许多比赛中有了巨大的进步成绩，解决了实际问题。后面还有各路大神提出了许多的优化方法。<br>2012-<strong>第三次兴起</strong>，有些饱和后，又出现了alexnet，有许多的trick技巧等，达到了许多提升。直接统治了深度学习。<br>2013，深度学习达到巨热，工业界超过学校成为最好的。<br>2020-<strong>第三次低谷？</strong><br><a id="more"></a><br><img src="http://p9f9koofz.bkt.clouddn.com/神经网络发展史.png" alt="avatar"><br>卷积神经网络，特殊的特征工程。主要用于解决图像识别问题。  </p><p>imagenet的比赛也即将结束，因为识别率已经达到饱和了。   </p><h3 id="深度学习和传统机器学习的区别"><a href="#深度学习和传统机器学习的区别" class="headerlink" title="深度学习和传统机器学习的区别"></a>深度学习和传统机器学习的区别</h3><p>神经网络相比svm等等的模型的优势在于，可以从很差的特征表示（如pixel）学习出很好的特征表示。<br>往往传统的机器学习算法需要比较好的特征表示形式，才能训练出好的结果，但是深度学习有非常高的模型复杂度、非线性拟合能力，可以自己学习到很好的特征表示。</p><p><a name="1.1"></a></p><h2 id="什么样的数据集不适合做深度学习"><a href="#什么样的数据集不适合做深度学习" class="headerlink" title="什么样的数据集不适合做深度学习"></a>什么样的数据集不适合做深度学习</h2><p>（1）<strong>数据集太小，数据样本不足</strong>时，深度学习相对其它机器学习算法，没有明显优势。<br>（2）<strong>数据集没有局部相关特性</strong>，首先举例说明，目前深度学习表现比较好的领域主要是图像／语音／自然语言处理等领域，这些领域的一个共性是局部相关性。<br>比如图像需要像素组成物体，语音需要组成单词，文本需要上下文。<br>相反比如预测一个人的健康状况，相关的参数会有年龄、职业、收入、家庭状况等各种元素，将这些元素打乱，并不会影响相关的结果，这样反而是不好的数据集。</p><p><a name="2.6"></a></p><h2 id="正则化有哪些，原理是怎样的（L0、L1、L2）"><a href="#正则化有哪些，原理是怎样的（L0、L1、L2）" class="headerlink" title="正则化有哪些，原理是怎样的（L0、L1、L2）"></a>正则化有哪些，原理是怎样的（L0、L1、L2）</h2><p><strong>L0：</strong><br>L0正则化即非零参数的个数。<br>很死板，可以理解为所有不为0的参数都接受惩罚，不论这个参数的参与程度、重要程度。<br>但是求导问题很难，是个NP难问题。（因为选哪个哪个不选，达到最好，不就是01背包吗）<br><img src="http://p9f9koofz.bkt.clouddn.com/L0.png" alt="avatar"> </p><hr><p><strong>L1：</strong>（Lasso）<br>L1正则化即各个参数绝对值之和。<br>相当于按罪行量刑，无论结果是好是坏。所以此处是按参数的影响程度来判断惩罚大小了。但是缺点在于计算导数的时候神特么出来一个绝对值，正负判断太恶心（<strong>也就是带来了在原点不可导的问题，需要单独处理</strong>）。<br><strong>适用：</strong>L1会把部分特征变成0，所以适合于只有少数特征起重要作用的情况下。起到<strong>参数稀疏的作用</strong>。<br><img src="http://p9f9koofz.bkt.clouddn.com/L1.png" alt="avatar"> </p><hr><p><strong>L2：</strong>（Ridge，岭回归）<br>L2正则化即各个参数的平方和。<br>虽然平方后惩罚变大了，但是存在λ调节，更加方便了求导。<br><strong>适用：</strong>L2会令特征趋近于0，适用于所有特征中，大部分特征都能起作用，而且起的作用很平均。（基本上L2是比L1要优秀的）<br><img src="http://p9f9koofz.bkt.clouddn.com/L2.png" alt="avatar"></p><hr><p><strong>Elastic Net：</strong><br>相当于是L1、L2的结合。</p><hr><p><strong>好处：</strong><br>1.简化模型，防止过拟合。<br>2.参数越小=模型越简单，<strong>因为越复杂的模型，越是会尝试对所有的样本进行拟合，甚至包括一些异常样本点，这就容易造成在较小的区间里预测值产生较大的波动，这种较大的波动也反映了在这个区间里的导数很大，而只有较大的参数值才能产生较大的导数。因此复杂的模型，其参数值会比较大。</strong></p><p><a name="2.7"></a></p><h2 id="激活函数用的什么，为什么用这个。还有哪些，特点是什么。"><a href="#激活函数用的什么，为什么用这个。还有哪些，特点是什么。" class="headerlink" title="激活函数用的什么，为什么用这个。还有哪些，特点是什么。"></a>激活函数用的什么，为什么用这个。还有哪些，特点是什么。</h2><p><strong>特性：</strong><br>(1) 非线性: 线性模型的表达能力不够，为了弥补线性模型的不足。<br>(2) 处处可导:因为在进行梯度下降，反向传播时需要计算激活函数的<br>偏导数，所以要求激活函数除个别点外，处处可导。<br>(3) 单调性:当激活函数是单调的时候，单层网络能够保证是凸函数。<br>(4) 输出值的范围: 当激活函数输出值有限的时候，基于梯度的优化方法会更加稳定，因为特征的表示受有限权值的影响更显著;当激活 函数的输出是无限的时候，模型的训练会更加高效，不过在这种情况 很小，一般需要更小的 learning rate.  </p><p>比如单纯的把神经元结合权值参加训练就是简单的线性组合，需要加入激活函数的非线性因子。解决线性模型的不足。</p><p>在如卷积神经网络中，激活函数是加在卷积层后的，在池化层是没有的。</p><hr><p><strong>常见的：</strong><br>（1）sigmoid<br>（2）tanh<br>（3）relu<br>（4）softmax（sigmoid的扩展，还满足多分类）</p><p><a name="2.8"></a></p><h2 id="DropOut加在了哪里，原理是怎样，为什么可以防止过拟合。"><a href="#DropOut加在了哪里，原理是怎样，为什么可以防止过拟合。" class="headerlink" title="DropOut加在了哪里，原理是怎样，为什么可以防止过拟合。"></a>DropOut加在了哪里，原理是怎样，为什么可以防止过拟合。</h2><p><strong>变相的减少了特征数量</strong>，可以防止过拟合  </p><p>hintion的直观解释和理由如下：</p><p>　　1. 由于每次用输入网络的样本进行权值更新时，隐含节点都是以一定概率随机出现，因此不能保证每2个隐含节点每次都同时出现，这样权值的更新不再依赖于有固定关系隐含节点的共同作用，<strong>阻止了某些特征仅仅在其它特定特征下才有效果的情况</strong>。</p><p>　　2. <strong>可以将dropout看作是模型平均的一种。对于每次输入到网络中的样本（可能是一个样本，也可能是一个batch的样本），其对应的网络结构都是不同的，但所有的这些不同的网络结构又同时share隐含节点的权值。</strong>这样不同的样本就对应不同的模型，是<strong>bagging</strong>的一种极端情况。个人感觉这个解释稍微靠谱些，和bagging，boosting理论有点像，但又不完全相同。</p><p><a name="2.9"></a></p><h2 id="为什么要做Normalization？怎样处理的？"><a href="#为什么要做Normalization？怎样处理的？" class="headerlink" title="为什么要做Normalization？怎样处理的？"></a>为什么要做Normalization？怎样处理的？</h2><p>因为当两个特征的取值范围相差很大的时候，对于模型的影响，取值范围大的特征有先天的优势。<br>分为离散型和连续型的特征有不同的处理方法。  </p><ol><li>连续型：线性缩放到[-1,1]，放缩到均值为0，方差为1.</li><li>离散型：使用one-hot编码，为了让距离的计算更加合理了。</li></ol><blockquote><p>one-hot 编码：<br>特征的所有离散的取值（n个）用（n维空间的向量表示）每个取值的表示里只有一个1。<br>这样可以保证每个取值间的距离是一样的。<br>特别的，离散特征的one-hot编码后每个取值维度都可以理解为一个单独的连续特征的维度。仍旧可以做归一化。</p></blockquote><p><strong>只有基于参数、距离的模型才必须要做normalization，而基于树的方法都不用。</strong></p><p><a name="2.10"></a></p><h2 id="什么是BN，加在了哪里，怎么加的，有什么效果，BN之后的放缩平移为什么，group-norm是什么。"><a href="#什么是BN，加在了哪里，怎么加的，有什么效果，BN之后的放缩平移为什么，group-norm是什么。" class="headerlink" title="什么是BN，加在了哪里，怎么加的，有什么效果，BN之后的放缩平移为什么，group norm是什么。"></a>什么是BN，加在了哪里，怎么加的，有什么效果，BN之后的放缩平移为什么，group norm是什么。</h2><p>从数学原理上讲，BN是为了解决<strong>covariate shift</strong>（协方差转换）和<strong>internal covariate shift</strong>的问题。（梯度消失和梯度爆炸）</p><h4 id="（1）什么是BN"><a href="#（1）什么是BN" class="headerlink" title="（1）什么是BN"></a>（1）什么是BN</h4><ol><li>做normalization，mean=0， variance= 1</li><li>用mini-batch, 方便求mean 和 variance的值</li><li>还有额外的 γ, β  来对新生成的distribution做一定幅度的放缩和平移</li></ol><h4 id="（2）BN之后为什么需要γ-β？（为什么要做完BN再进行scale-shift）"><a href="#（2）BN之后为什么需要γ-β？（为什么要做完BN再进行scale-shift）" class="headerlink" title="（2）BN之后为什么需要γ, β？（为什么要做完BN再进行scale+shift）"></a>（2）BN之后为什么需要γ, β？（为什么要做完BN再进行scale+shift）</h4><p>BN给每个神经元都增加了两个参数γ, β，为了给单纯的平移操作增加非线性因素，从而带来不同形状的高斯分布，并且也是经过训练学习获得的。</p><p>因为normalization会导致新的分布丧失从前层传递过来的特征与知识。加入γ, β，是为了让新生成的分布，能够利用好接下来的激活函数的非线性功能。</p><p>调整方向是向之前的数据分布，为了让因训练所需而“刻意”加入的BN能够有可能还原最初的输入。避免强行使用正态分布。</p><h4 id="（3）BN作用"><a href="#（3）BN作用" class="headerlink" title="（3）BN作用"></a>（3）BN作用</h4><p>作用：<br>1、提高梯度在网络中的流动。Normalization能够使特征全部缩放到[0,1]，这样在反向传播时候的梯度都是在1左右，<strong>避免了梯度消失现象</strong>。（梯度消失由链式法则+激活函数+权重初始化引起）<br>2、支持更高的学习速率，提升学习速率。<strong>归一化后的数据能够快速的达到收敛</strong>。（也是因为避免了梯度消失，增加了梯度的流动。）<br>3、<strong>减少模型训练对初始化的依赖</strong>。<br>从根源上讲，是防止了梯度消失，因为梯度下降的时候，所求的导数如果原数据的范围大小不一，得到的结果会随着深度的加深缩小很大，如果方差在0，1那梯度会在1左右。</p><h4 id="（4）加在了哪"><a href="#（4）加在了哪" class="headerlink" title="（4）加在了哪"></a>（4）加在了哪</h4><p>在中日韩人脸分类的项目里，我们的BN是加在了全连接层，前面的vgg是用预训练好的VGG19.看文章说卷积层也是可以BN的，没试过。</p><h4 id="（5）BN在卷积层"><a href="#（5）BN在卷积层" class="headerlink" title="（5）BN在卷积层"></a>（5）BN在卷积层</h4><p>BN在卷积层当然是针对每个通道（卷积核）做BN。</p><h4 id="（6）batch-layer-instance-group-norm"><a href="#（6）batch-layer-instance-group-norm" class="headerlink" title="（6）batch/layer/instance/group norm"></a>（6）batch/layer/instance/group norm</h4><p>其实就是做normalization的结果计算关注面不同，如下图，很直观。<br><img src="http://p9f9koofz.bkt.clouddn.com/多种norm.png" alt="avatar">  </p><table><thead><tr><th style="text-align:left">norm类型</th><th style="text-align:center">做法</th><th style="text-align:center">解释</th></tr></thead><tbody><tr><td style="text-align:left"><strong>BatchNorm</strong></td><td style="text-align:center">batch方向做归一化，算N*H*W的均值</td><td style="text-align:center"><strong>整批样本</strong> + <strong>每个channel</strong>的计算结果做一次normalization</td></tr><tr><td style="text-align:left"><strong>LayerNorm</strong></td><td style="text-align:center">channel方向做归一化，算C*H*W的均值</td><td style="text-align:center"><strong>每个样本</strong> + <strong>所有channel</strong>的计算结果做一次normalization</td></tr><tr><td style="text-align:left"><strong>InstanceNorm</strong></td><td style="text-align:center">一个channel内做归一化，算H*W的均值</td><td style="text-align:center"><strong>每个样本</strong> + <strong>每个channel</strong>的计算结果做一次normalization</td></tr><tr><td style="text-align:left"><strong>GroupNorm</strong></td><td style="text-align:center">将channel方向分group，然后每个group内做归一化，算(C//G)*H*W的均值</td><td style="text-align:center"><strong>每个样本</strong> + <strong>一组channel</strong>的计算结果做一次normalization</td></tr></tbody></table><p>这些做法（group norm）相比于batch norm，不再局限于batch的大小，这样就不会让BN的时候因为batch小，归一化的方向不明确。但是也不会太大，令显存不够。</p><p><a name="2.11"></a></p><h2 id="在pooling层是如何反向传播的"><a href="#在pooling层是如何反向传播的" class="headerlink" title="在pooling层是如何反向传播的"></a>在pooling层是如何反向传播的</h2><p>首先CNN中的pooling层是不可导的一个阶段，在反向传播中需要把pooling层下降的采样还原，同时<strong>需要保证传递的loss（或者梯度）总和不变</strong>，这样需要对不同的pooling方式做不同的处理。  </p><h4 id="（1）average-pooling"><a href="#（1）average-pooling" class="headerlink" title="（1）average pooling"></a>（1）average pooling</h4><p>由于在前向传播中（如2X2的）是取了四个像素的均值作为一个像素。那么反向传播中就把这个结果等分四份变回四个像素。<br><img src="http://p9f9koofz.bkt.clouddn.com/反向传播meanpooling.jpg" alt="avatar">  </p><h4 id="（2）max-pooling"><a href="#（2）max-pooling" class="headerlink" title="（2）max pooling"></a>（2）max pooling</h4><p>由于在就前向传播中是取了四个像素中的最大值作为一个像素。那么反向传播的时候就把这个结果返回到四个像素中的随机一个，其余为0.</p><h4 id="为什么反向传播中令四个格子的和为前向传播的结果"><a href="#为什么反向传播中令四个格子的和为前向传播的结果" class="headerlink" title="为什么反向传播中令四个格子的和为前向传播的结果"></a>为什么反向传播中令四个格子的和为前向传播的结果</h4><p>因为你想啊，前向传播的结果是权值*每个格子值求和，所以这样操作才能保证前向传播、反向传播的卷积核扫描结果相同啊。</p><p><a name="2.12"></a></p><h2 id="什么是梯度消失、梯度爆炸"><a href="#什么是梯度消失、梯度爆炸" class="headerlink" title="什么是梯度消失、梯度爆炸"></a>什么是梯度消失、梯度爆炸</h2><p>梯度消失指的是权重不再更新，直观上看是从最后一层到第一层权重的更新越来越慢，直至不更新。本质原因是反向传播的连乘效应，导致最后对权重的偏导接近于零。</p><p>简单地说，根据<strong>链式法则</strong>，同时也取决于所用的激活函数或初始权重过大。如果每一层神经元对<strong>上一层的输出的偏导</strong>乘上权重结果都小于1的话，那么即使这个结果是0.99，在经过足够多层传播之后，误差对输入层的偏导会趋于0。导致梯度消失（发生更多，根据激活函数的范围）。<br>相反如果大于1的话，就会越来越大。导致梯度爆炸。</p><p>网络层数太多是导致梯度消失或者梯度爆炸的直接原因, 使用S型激活函数(如:sigmoid函数,tanh函数)会导致梯度消失问题，初始权重设置太大会导致梯度爆炸。</p><p>如sigmoid，如果初始权重过大，那么激活值会在sigmoid的两侧，那里的导数都趋近0，那么梯度肯定就消失了。<br><img src="http://p9f9koofz.bkt.clouddn.com/sigmoid.png" alt="avatar">  </p><p>所以这就是BN所解决的问题，将activation set每次激活之前做规范，让深层每一层都变得和浅层一样。</p><p>并且用ReLU和更好的初始化方法也能起这个作用。</p><p><a name="2.13"></a></p><h2 id="卷积神经网络的原理-CNN为什么work？👍"><a href="#卷积神经网络的原理-CNN为什么work？👍" class="headerlink" title="卷积神经网络的原理-CNN为什么work？👍"></a>卷积神经网络的原理-CNN为什么work？👍</h2><p>首先讲一下<strong>卷积的操作</strong>，无非是窗口滑动，其中<strong>窗口的计算方式</strong>，其实就是窗口覆盖的图像里所有的点，和窗口的每个点都一一对应，相乘求和即可，并不是矩阵相乘哈。每一个窗口（移动一次）计算出一个值。（但是实际在底层计算的时候不是一步步扫描来计算的，这样比较浪费GPU的并行能力，更多是用两个大矩阵相乘直接得到结果）<br>并且<strong>多个channel对同一个filter有不同权重矩阵</strong>的，但是不论channel（depth）是多少都是在Width、Height维度得到一个结果。等于不同的filter对同一区域不同channel的矩阵点乘的和。（channel数就是当前层的输入数据的特征维度）<br>也就是说，<strong>卷积层输出的结果的channel数不由本层输入的channel数决定，而由本层设定的filter数决定</strong>。<br>每个filter有不同的功效，如捕捉边缘、棱角、模糊、形状、文理等。<br><img src="https://pic7.zhimg.com/v2-4fd0400ccebc8adb2dffe24aac163e70_b.gif" alt="avatar"><br><img src="https://pic1.zhimg.com/v2-0bc83b72ef50099b70a10cc3ab528f62_b.gif" alt="avatar"><br>pooling层的作用是下采样，去掉部分不必要的冗余信息。</p><p>原理：<strong>局部连接/感知</strong>(Local Connection)、<strong>权值共享</strong>(Weight Sharing)和<strong>池化层</strong>(Pooling) 中的降采样(Down-Sampling)。满足了图像的空间不变形、旋转和视角不变性、尺寸不变性的先验知识。</p><p>局部连接和权值共享降低了参数量，使训练复杂度大大下降，并减轻了过拟合，权值共享还赋予了卷积网络对平移的容忍性<br>池化层降采样则进一步降低了输出参数量，并赋予模型对轻度形变的容忍性，提高了模型的泛化能力。</p><p>负责特征抓取的卷积层来学习“如何观察”</p><p><strong>zero padding</strong>：<br>加？（根据卷积的尺寸、strike）层zero padding可以避免卷积层之后使图片尺寸减小。</p><p><a name="2.20"></a></p><h2 id="全连接层的作用是什么"><a href="#全连接层的作用是什么" class="headerlink" title="全连接层的作用是什么"></a>全连接层的作用是什么</h2><p>简单来说是为了保存模型复杂度。<br>FC可视作模型表示能力的“防火墙”，特别是在源域与目标域差异较大的情况下，FC可保持较大的模型capacity从而保证模型表示能力的迁移。（冗余的参数并不一无是处。）<br>全连接层将之前卷积层输出的立方体平摊为一个向量，将最后的输出映射到线性可分的空间。</p><p><a name="2.14"></a></p><h2 id="weight-initialization-的方法"><a href="#weight-initialization-的方法" class="headerlink" title="weight initialization 的方法"></a>weight initialization 的方法</h2><p>lecun_uniform /  glorot_normal / he_normal / batch_normal<br>在TensorFlow里有Xavier的权重初始化的方法。</p><p><a name="2.15"></a></p><h2 id="fine-tuning（微调）"><a href="#fine-tuning（微调）" class="headerlink" title="fine-tuning（微调）"></a>fine-tuning（微调）</h2><p><a name="2.16"></a></p><h2 id="为什么CNN不止可以在图像里使用，还可以在NLP、语音等领域使用"><a href="#为什么CNN不止可以在图像里使用，还可以在NLP、语音等领域使用" class="headerlink" title="为什么CNN不止可以在图像里使用，还可以在NLP、语音等领域使用"></a>为什么CNN不止可以在图像里使用，还可以在NLP、语音等领域使用</h2><p>答这个问题的trick在于描述CNN的特性，局部连接／权值共享／池化操作／多层次结构。</p><p>局部连接使网络可以提取数据的局部特征；权值共享大大降低了网络的训练难度，一个Filter只提取一个特征，在整个图片（或者语音／文本） 中进行卷积；池化操作与多层次结构一起，实现了数据的降维，将低层次的局部特征组合成为较高层次的特征，从而对整个图片进行表示。</p><p>以上几个不相关问题的相关性在于，都存在局部与整体的关系，由低层次的特征经过组合，组成高层次的特征，并且得到不同特征之间的空间相关性。低层次的直线／曲线等特征，组合成为不同的形状，最后得到整体的表示。</p><p><a name="2.17"></a></p><h2 id="learning-rate应该怎么设"><a href="#learning-rate应该怎么设" class="headerlink" title="learning rate应该怎么设"></a>learning rate应该怎么设</h2><p>首先太大会让梯度不能快速有效下降甚至会上升。</p><p>太小又学习的太慢了。</p><p>可以先给定一个不大也不小的，如果下降的慢就调大。</p><p>与SGD相关的学习速率，可以让他在趋近于最优值的时候变小趋近于0.（因为SGD的梯度下降每次只关注一个样本，所以无法真正的梯度下降到最优，而是在最优附近不断的波动，所以可以这样变化学习速率）</p><p>现在有许多自适应调整学习速率的梯度下降方法，在TensorFlow里使用不同的方法即可。</p><p><a name="2.19"></a></p><h2 id="为什么很多做人脸的Paper会最后加入一个Local-Connected-Conv？"><a href="#为什么很多做人脸的Paper会最后加入一个Local-Connected-Conv？" class="headerlink" title="为什么很多做人脸的Paper会最后加入一个Local Connected Conv？"></a>为什么很多做人脸的Paper会最后加入一个Local Connected Conv？</h2><p>Local Connected Conv = Local-Conv. 来自Facebook的Deep Face论文。<br>原理：所谓Local-Conv就是该卷积层的权值不共享。（在经历了两次全卷积＋一次池化（c+mp+c的顺序），提取了低层次的边缘／纹理等特征。后接了3个Local-Conv层）</p><p>这样做的原因：人脸在不同的区域存在不同的特征（眼睛／鼻子／嘴的分布位置相对固定）。而之前的全卷积是将一些低层次的纹理特征组合表达的更复杂得到大的特征之后，当不存在全局的局部特征分布时，Local-Conv更适合特征的提取。而这里的情况里，把人脸都做了3D模型来将人脸对齐，所有特征的位置都相对固定。算是对特殊处理后的人脸的一个先验了。（相比一般的CNN例子，图像是允许旋转平移等，都识别为同一个错误）  </p><p>这样的结果会大大增加要训练的参数量。</p><p><a name="3.0"></a></p><h2 id="为什么很早就有的机器学习、深度学习、神经网络现在才真正发展"><a href="#为什么很早就有的机器学习、深度学习、神经网络现在才真正发展" class="headerlink" title="为什么很早就有的机器学习、深度学习、神经网络现在才真正发展"></a>为什么很早就有的机器学习、深度学习、神经网络现在才真正发展</h2><p>答：神经网络发展史。（问题1）</p><p>数据、算法、硬件。</p><p>还有新的技术，将问题变得可以优化。</p><p>参考一下深度学习这本书的序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a name=&quot;1.0&quot;&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;深度学习（神经网络）发展史&quot;&gt;&lt;a href=&quot;#深度学习（神经网络）发展史&quot; class=&quot;headerlink&quot; title=&quot;深度学习（神经网络）发展史&quot;&gt;&lt;/a&gt;深度学习（神经网络）发展史&lt;/h2&gt;&lt;p&gt;深度学习=预测问题&lt;/p&gt;
&lt;p&gt;1940s出现。1943 抽象的神经元模型MP。1949年心理学家Hebb提出了Hebb学习率，认为人脑神经细胞 上的连接强度上可以变化的。&lt;br&gt;1958-&lt;strong&gt;20世纪50年代 第一次兴起&lt;/strong&gt; 感知机，单层神经元组成的神经网络。可以更改权重。（神经网络第一次浪潮）原理类似于svm的分类方式，当发现有分错的情况，调整权重。但是这是一个线性的分类器，只能分出简单的情况。&lt;br&gt;1969-&lt;strong&gt;20世纪60年代 第一次低谷&lt;/strong&gt; Minsky 感知机被数学证明了局限性。OR/AND可以分类，但XOR异或决无法解决，除非将计算增加为两层，但是计算量过大，无法学习。进入了神经网络的寒冬。&lt;br&gt;1986-&lt;strong&gt;20世纪80年代 第二次兴起&lt;/strong&gt; Rumelhar 和 Hintor等人提出了BP算法（链式法则），解决了两层神经网络所需要的复杂计算量。 1989年bell实验室用识别手写邮编在现实应用验证了BP的价值。但是BP慢、容易局部最优、太多参数、很难调参、难以得到稳定的结果。&lt;br&gt;1995年-&lt;strong&gt;20世纪90年代 第二次低谷&lt;/strong&gt;，Vapnik等人提出了支持向量机(Support Vector Machines)算法，很快就在若干个方面体现出了对比神经网络的优势: 无需调参，高效，全局最优解。然后神经网络被吊打。1997年提出了LSTM，1998年提出LeNet网络。&lt;br&gt;2006，hinton提出深度信念网，通过预训练+微调使得在反向传播之前就有了一个很好的起点。且在许多比赛中有了巨大的进步成绩，解决了实际问题。后面还有各路大神提出了许多的优化方法。&lt;br&gt;2012-&lt;strong&gt;第三次兴起&lt;/strong&gt;，有些饱和后，又出现了alexnet，有许多的trick技巧等，达到了许多提升。直接统治了深度学习。&lt;br&gt;2013，深度学习达到巨热，工业界超过学校成为最好的。&lt;br&gt;2020-&lt;strong&gt;第三次低谷？&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="面经总结" scheme="blog.lovelaolao.xin/categories/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="思考题" scheme="blog.lovelaolao.xin/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
      <category term="深度学习" scheme="blog.lovelaolao.xin/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>学习方法</title>
    <link href="blog.lovelaolao.xin/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    <id>blog.lovelaolao.xin/机器学习/学习方法/</id>
    <published>2018-05-08T12:06:00.000Z</published>
    <updated>2018-05-28T08:20:00.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="梯度下降法"><a href="#梯度下降法" class="headerlink" title="梯度下降法"></a>梯度下降法</h1><ul><li>求解无约束最优化问题的常用方法。  </li><li>迭代算法，每一步计算目标函数的梯度向量。  </li><li>根据<strong>泰勒一阶展开式</strong>，求出在x(k)的梯度，令x向量沿<strong>梯度向量</strong>方向更新。  </li><li>当梯度或x本身更新幅度低于阈值停止更新。  </li><li>当目标函数是凸函数，梯度下降可以达到全局最优，但是梯度下降的收敛速度未必快。</li></ul><a id="more"></a><h1 id="牛顿法和拟牛顿法"><a href="#牛顿法和拟牛顿法" class="headerlink" title="牛顿法和拟牛顿法"></a>牛顿法和拟牛顿法</h1><ul><li>牛顿法和拟牛顿法都是求解无约束最优化问题的常用方法。</li><li><strong>收敛速度快</strong>，迭代算法，每一步需要求解目标函数的<strong>海塞（Hesse）矩阵，</strong>计算比较复杂。</li><li><strong>拟牛顿法用正定矩阵近似海塞矩阵的逆矩阵或海塞矩阵简化计算过程</strong>。</li></ul><h3 id="牛顿法："><a href="#牛顿法：" class="headerlink" title="牛顿法："></a>牛顿法：</h3><ul><li>二阶泰勒展开，得到梯度向量，再求f(x)的海塞矩阵（海塞矩阵可以由已知公式关系直接获得，而逆矩阵必须从这里再计算）。</li><li>如果梯度向量小于阈值，不更新。</li><li>如果海塞矩阵是正定的，那么可以得到全局最优。</li><li>通过梯度向量和海塞矩阵（须求逆矩阵）求x的更新梯度。</li><li>其中海塞矩阵的逆求解比较复杂。</li></ul><h3 id="拟牛顿法（BFGS算法）："><a href="#拟牛顿法（BFGS算法）：" class="headerlink" title="拟牛顿法（BFGS算法）："></a>拟牛顿法（BFGS算法）：</h3><ul><li>优化牛顿法，用一个好计算的n阶矩阵代替海塞矩阵的逆矩阵。</li><li>由于海塞矩阵满足一些条件（拟牛顿条件）</li><li>如果假设海塞矩阵逆矩阵正定，可以得到一个矩阵作为海塞矩阵的代替，或者得到另一个矩阵作为海塞矩阵的逆矩阵。（根据已知的公式关系推导出）</li><li>此外还有如DFP算法寻找代替矩阵。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;梯度下降法&quot;&gt;&lt;a href=&quot;#梯度下降法&quot; class=&quot;headerlink&quot; title=&quot;梯度下降法&quot;&gt;&lt;/a&gt;梯度下降法&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;求解无约束最优化问题的常用方法。  &lt;/li&gt;
&lt;li&gt;迭代算法，每一步计算目标函数的梯度向量。  &lt;/li&gt;
&lt;li&gt;根据&lt;strong&gt;泰勒一阶展开式&lt;/strong&gt;，求出在x(k)的梯度，令x向量沿&lt;strong&gt;梯度向量&lt;/strong&gt;方向更新。  &lt;/li&gt;
&lt;li&gt;当梯度或x本身更新幅度低于阈值停止更新。  &lt;/li&gt;
&lt;li&gt;当目标函数是凸函数，梯度下降可以达到全局最优，但是梯度下降的收敛速度未必快。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="机器学习" scheme="blog.lovelaolao.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="学习方法" scheme="blog.lovelaolao.xin/tags/%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统</title>
    <link href="blog.lovelaolao.xin/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    <id>blog.lovelaolao.xin/机器学习/推荐系统/</id>
    <published>2018-04-27T16:00:00.000Z</published>
    <updated>2018-05-28T07:36:18.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="推荐系统方法对比"><a href="#推荐系统方法对比" class="headerlink" title="推荐系统方法对比"></a>推荐系统方法对比</h1><a id="more"></a><table><thead><tr><th style="text-align:center">推荐系统方法</th><th style="text-align:center">特点</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">基于用户属性的推荐</td><td style="text-align:center">根据系统用户的基本信息发现用户的相关程度，然后将相似用户喜爱的其他物品推荐给当前用户</td><td style="text-align:center">不需要历史数据，没有冷启动问题；不依赖于物品的属性，因此其他领域的问题都可无缝接入</td><td style="text-align:center">算法比较粗糙，效果很难令人满意，只适合简单的推荐</td></tr><tr><td style="text-align:center">基于内容的推荐</td><td style="text-align:center">使用物品本身的相似度而不是用户的相似度</td><td style="text-align:center">对用户兴趣可以很好的建模，并通过对物品属性维度的增加，获得更好的推荐精度</td><td style="text-align:center">物品的属性有限，很难有效的得到更多数据；物品相似度的衡量标准只考虑到了物品本身，有一定的片面性；需要用户的物品的历史数据，有冷启动的问题</td></tr><tr><td style="text-align:center">基于关联规则的推荐</td><td style="text-align:center">如“购物篮”场景，挖掘一些数据的依赖关系，可以找到哪些物品经常被同时购买，或者用户购买了一些物品后通常会购买哪些其他的物品。</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">协同过滤</td><td style="text-align:center">利用集体智慧的一个典型方法，收集数据（用户的历史行为数据）——找到相似用户和物品（计算用户间以及物品间的相似度）——进行推荐（分为基于用户、基于物品的协同过滤）。<strong>基于用户的协同过滤</strong>——基于用户属性的推荐比较UserCF：将一个用户对所有物品的偏好作为一个向量来计算用户之间的相似度。<strong>基于物品的协同过滤</strong>——基于内容的推荐比较ItemCF：所有用户对某个物品的偏好作为一个向量来计算物品之间的相似度。user和item的协同过滤，针对不同的情况，当用户量远远大于物品数量，userCF会很稳定，itemCF更加棒。</td><td style="text-align:center">不需要对物品或者用户进行严格的建模，而且不要求物品的描述是机器可理解的，所以这种方法也是领域无关的；这种方法计算出来的推荐是开放的，可以共用他人的经验，很好的支持用户发现潜在的兴趣偏好</td><td style="text-align:center">方法的核心是基于历史数据，所以对新物品和新用户都有“冷启动”的问题；推荐的效果依赖于用户历史偏好数据的多少和准确性；在大部分的实现中，用户历史偏好是用稀疏矩阵进行存储的，而稀疏矩阵上的计算有些明显的问题，包括可能少部分人的错误偏好会对推荐的准确度有很大的影响等等；<strong>对于一些特殊品味的用户不能给予很好的推荐</strong>；由于以历史数据为基础，抓取和建模用户的偏好后，很难修改或者根据用户的使用演变，从而导致这个方法不够灵活；</td></tr><tr><td style="text-align:center">混合推荐机制</td><td style="text-align:center">1.加权的混合；2.切换的混合；3.分区的混合；4.分层的混合</td><td style="text-align:center">1.用线性公式（linearformula）将几种不同的推荐按照一定权重组合起来；2.对于不同的情况（数据量，系统运行状况，用户和物品的数目等），推荐策略可能有很大的不同，选取最合适的；3.采用多种推荐机制，并将不同的推荐结果分不同的区显示给用户；4.类似于boosting；</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;推荐系统方法对比&quot;&gt;&lt;a href=&quot;#推荐系统方法对比&quot; class=&quot;headerlink&quot; title=&quot;推荐系统方法对比&quot;&gt;&lt;/a&gt;推荐系统方法对比&lt;/h1&gt;
    
    </summary>
    
      <category term="机器学习" scheme="blog.lovelaolao.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="推荐系统" scheme="blog.lovelaolao.xin/tags/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Python面试必考</title>
    <link href="blog.lovelaolao.xin/Language/Python/python/"/>
    <id>blog.lovelaolao.xin/Language/Python/python/</id>
    <published>2018-04-20T16:00:00.000Z</published>
    <updated>2018-05-28T07:55:50.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是PEP8"><a href="#什么是PEP8" class="headerlink" title="什么是PEP8"></a>什么是PEP8</h2><p>PEP8是一个编程规范，内容是一些关于如何让你的程序更具可读性的建议。</p><h2 id="Python是如何被解释的？"><a href="#Python是如何被解释的？" class="headerlink" title="Python是如何被解释的？"></a>Python是如何被解释的？</h2><p>Python是一种解释性语言，它的源代码可以直接运行。Python解释器会将源代码转换成中间语言，之后再翻译成机器码再执行。</p><a id="more"></a><h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2><p>Python的内存管理是由私有heap空间管理的。所有的Python对象和数据结构都在一个私有heap中。程序员没有访问该heap的权限，只有解释器才能对它进行操作。为Python的heap空间分配内存是由Python的内存管理模块进行的，其核心API会提供一些访问该模块的方法供程序员使用。Python有自带的垃圾回收系统，它回收并释放没有被使用的内存，让它们能够被其他程序使用。</p><h2 id="数组和元组之间的区别是什么？"><a href="#数组和元组之间的区别是什么？" class="headerlink" title="数组和元组之间的区别是什么？"></a>数组和元组之间的区别是什么？</h2><p>数组和元组之间的区别：数组内容是可以被修改的，而元组内容是只读的。另外，元组可以被哈希，比如作为字典的关键字。</p><h2 id="参数按值传递和引用传递"><a href="#参数按值传递和引用传递" class="headerlink" title="参数按值传递和引用传递"></a>参数按值传递和引用传递</h2><p>python中的函数值传递，首先python传递参数都是传递对象的形式。<strong>如果是可以修改的对象，就是引用传递，修改的是对象本身</strong>，<strong>如果是不可以修改的对象，就是按值传递，不能修改对象本身，修改的是对象的复制。</strong><br>比如传int，int就是不可改变的对象，10是不能变成2的。如果是传递数组，就可以改变。</p><h2 id="Python都有哪些自带的数据结构？"><a href="#Python都有哪些自带的数据结构？" class="headerlink" title="Python都有哪些自带的数据结构？"></a>Python都有哪些自带的数据结构？</h2><p>Python自带的数据结构分为可变的和不可变的。<br>可变的有：数组、集合、字典；<br>不可变的有：字符串、元组、数。</p><h2 id="什么是Python的命名空间？"><a href="#什么是Python的命名空间？" class="headerlink" title="什么是Python的命名空间？"></a>什么是Python的命名空间？</h2><p>在Python中，所有的名字都存在于一个空间中，它们在该空间中存在和被操作——这就是命名空间。它就好像一个盒子，每一个变量名字都对应装着一个对象。当查询变量的时候，会从该盒子里面寻找相应的对象。</p><h2 id="在Python中什么是slicing？"><a href="#在Python中什么是slicing？" class="headerlink" title="在Python中什么是slicing？"></a>在Python中什么是slicing？</h2><p>Slicing是一种在有序的对象类型中（数组，元组，字符串）节选某一段的语法。</p><h2 id="如何在Python中拷贝一个对象？"><a href="#如何在Python中拷贝一个对象？" class="headerlink" title="如何在Python中拷贝一个对象？"></a>如何在Python中拷贝一个对象？</h2><p>如果要在Python中拷贝一个对象，大多时候你可以用copy.copy()（这样会让新的对象的内容都是旧对象内容的引用，会被动修改）或者copy.deepcopy()。但并不是所有的对象都可以被拷贝。</p><h2 id="Python中的负索引是什么？"><a href="#Python中的负索引是什么？" class="headerlink" title="Python中的负索引是什么？"></a>Python中的负索引是什么？</h2><p>倒数第几个的索引</p><h2 id="Python中的模块和包是什么？"><a href="#Python中的模块和包是什么？" class="headerlink" title="Python中的模块和包是什么？"></a>Python中的模块和包是什么？</h2><p>在Python中，模块是搭建程序的一种方式。每一个Python代码文件都是一个模块，并可以引用其他的模块，比如对象和属性。<br>一个包含许多Python代码的文件夹是一个包。一个包可以包含模块和子文件夹。</p><h2 id="简要描述Python的垃圾回收机制（garbage-collection）。"><a href="#简要描述Python的垃圾回收机制（garbage-collection）。" class="headerlink" title="简要描述Python的垃圾回收机制（garbage collection）。"></a>简要描述Python的垃圾回收机制（garbage collection）。</h2><p>类似于java</p><p>Python在内存中存储了每个对象的引用计数（reference count）。如果计数值变成0，那么相应的对象就会小时，分配给该对象的内存就会释放出来用作他用。 （偶尔也会出现引用循环（reference cycle）。垃圾回收器会定时寻找这个循环，并将其回收。举个例子，假设有两个对象o1和o2，而且符合o1.x == o2和o2.x == o1这两个条件。如果o1和o2没有其他代码引用，那么它们就不应该继续存在。但它们的引用计数都是1。）<br>Python中使用了某些启发式算法（heuristics）来加速垃圾回收。例如，越晚创建的对象更有可能被回收。对象被创建之后，垃圾回收器会分配它们所属的代（generation）。每个对象都会被分配一个代，而被分配更年轻代的对象是优先被处理的。</p><h2 id="什么是lambda函数？它有什么好处"><a href="#什么是lambda函数？它有什么好处" class="headerlink" title="什么是lambda函数？它有什么好处?"></a>什么是lambda函数？它有什么好处?</h2><p>lambda 表达式，通常是在需要一个函数，但是又不想费神去命名一个函数的场合下使用，也就是指匿名函数<br>lambda函数：首要用途是指点短小的回调函数</p><h2 id="如何在一个function里面设置一个全局的变量？"><a href="#如何在一个function里面设置一个全局的变量？" class="headerlink" title="如何在一个function里面设置一个全局的变量？"></a>如何在一个function里面设置一个全局的变量？</h2><p>global修饰</p><h2 id="整数、浮点数的除法运算"><a href="#整数、浮点数的除法运算" class="headerlink" title="整数、浮点数的除法运算"></a>整数、浮点数的除法运算</h2><pre><code>5/2 = 2.55.0/2 = 2.55//2 = 25.0//2.0 = 2.0</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;什么是PEP8&quot;&gt;&lt;a href=&quot;#什么是PEP8&quot; class=&quot;headerlink&quot; title=&quot;什么是PEP8&quot;&gt;&lt;/a&gt;什么是PEP8&lt;/h2&gt;&lt;p&gt;PEP8是一个编程规范，内容是一些关于如何让你的程序更具可读性的建议。&lt;/p&gt;
&lt;h2 id=&quot;Python是如何被解释的？&quot;&gt;&lt;a href=&quot;#Python是如何被解释的？&quot; class=&quot;headerlink&quot; title=&quot;Python是如何被解释的？&quot;&gt;&lt;/a&gt;Python是如何被解释的？&lt;/h2&gt;&lt;p&gt;Python是一种解释性语言，它的源代码可以直接运行。Python解释器会将源代码转换成中间语言，之后再翻译成机器码再执行。&lt;/p&gt;
    
    </summary>
    
      <category term="Language" scheme="blog.lovelaolao.xin/categories/Language/"/>
    
      <category term="Python" scheme="blog.lovelaolao.xin/categories/Language/Python/"/>
    
    
      <category term="面试必考" scheme="blog.lovelaolao.xin/tags/%E9%9D%A2%E8%AF%95%E5%BF%85%E8%80%83/"/>
    
      <category term="Python" scheme="blog.lovelaolao.xin/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>一些需要记的题</title>
    <link href="blog.lovelaolao.xin/Algorithm/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/%E4%B8%80%E4%BA%9B%E9%9C%80%E8%A6%81%E8%AE%B0%E7%9A%84%E9%A2%98/"/>
    <id>blog.lovelaolao.xin/Algorithm/算法技巧/一些需要记的题/</id>
    <published>2018-04-17T11:05:00.000Z</published>
    <updated>2018-05-28T08:39:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="寻找连续子数组、子矩阵的和为精确值的情况"><a href="#寻找连续子数组、子矩阵的和为精确值的情况" class="headerlink" title="寻找连续子数组、子矩阵的和为精确值的情况"></a>寻找连续子数组、子矩阵的和为精确值的情况</h2><p>数组、矩阵是无序的，就没办法用窗口类的O(N、N^2)时间复杂度方法。<br>最简单的思考方式就是用二、三维的动态规划，计算所有i到j的情况。但是算的时候就发现了，有很多的冗余计算。</p><h3 id="DP降维—问题转化"><a href="#DP降维—问题转化" class="headerlink" title="DP降维—问题转化"></a>DP降维—问题转化</h3><a id="more"></a><p>由于是连续的子数组、子矩阵。必然存在一下关系：<br>(数组的话是第i到第j元素的子数组，矩阵的话是左上角在i坐标，右下角在j坐标的子矩阵。)：<strong><code>sum(i,j) = sum(0,j) - sum(0,i)</code></strong><br>那么<strong>所有从起点到终点的问题都变成了从0点到终点的问题之间的差</strong>。<br>从而动态规划的问题维数就变成了<code>二 =&gt; 一</code>，<code>三 =&gt; 二</code>。</p><h3 id="O-N-的精确找答案—Map"><a href="#O-N-的精确找答案—Map" class="headerlink" title="O(N)的精确找答案—Map"></a>O(N)的精确找答案—Map</h3><p>虽然用更高效的形式得到了所有子数组、子矩阵的<code>sum(i,j)</code>。但是查找还是要遍历所有起终点之间的差。<br>可以讲所有的<code>sum(0,i)</code>全都保存到map里，key为和的值，这样在<strong>找所有满足<code>k = sum(0,j) - sum(0,i)</code>的情况时，直接<code>map.find(sum(0,i) - k)</code></strong>就好了，类似于two sum的问题。</p><h2 id="快速选择-VS-堆排序-得到第k个结果"><a href="#快速选择-VS-堆排序-得到第k个结果" class="headerlink" title="快速选择 VS 堆排序 得到第k个结果"></a>快速选择 VS 堆排序 得到第k个结果</h2><p><strong>有可以达到O(N)比堆排序更优秀的算法：快速选择算法。</strong></p><table><thead><tr><th style="text-align:center">得到第k小的元素</th><th style="text-align:center">时间复杂度</th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:center">堆排序（大顶堆找k小，小顶堆找k大）</td><td style="text-align:center">O(klogn)</td><td style="text-align:center">可以动态更新，添加、删除堆元素后很快得到新结果</td><td style="text-align:center">单纯从固定数组得到第k元素的话时间复杂度不如快速选择</td></tr><tr><td style="text-align:center">快速选择算法</td><td style="text-align:center">平均O(N)（最差O(N^2)）</td><td style="text-align:center">从固定数组得到第k元素可以达到O(N)的完美时间复杂度</td><td style="text-align:center">必须是固定数组</td></tr></tbody></table><h3 id="快速选择算法"><a href="#快速选择算法" class="headerlink" title="快速选择算法"></a>快速选择算法</h3><p>（原理上类似二分查找，但是二分查找只能寻找有序集合）<br>借助快速排序的partition方法，不断地用pivot得到其最终位置，然后和k比，然后在k应该在的那一侧继续重复，直到精准的找到pivot位置为k。  </p><p>为什么时间复杂度是O(N)不是快排的O(NlogN)：<br>因为快排需要得到pivot之后两侧递归继续partition。但是快速选择得知k位置所在一侧之后，会舍弃另一侧不考虑。<br>这样总的比较次数就是<code>n+n/2+n/4+...+1 = 2*n</code>时间复杂度也就是O(N)。<br>这里n/2^m是指平局情况的比较次数。</p><h2 id="二叉树两个结点最近公共父节点"><a href="#二叉树两个结点最近公共父节点" class="headerlink" title="二叉树两个结点最近公共父节点"></a>二叉树两个结点最近公共父节点</h2><h3 id="法一：DFS"><a href="#法一：DFS" class="headerlink" title="法一：DFS"></a>法一：DFS</h3><p>没有重复val的结点。这个题非常好理解，但是不太好写，因为有一点要理解，<strong>如果在遍历中能找到其中一个目标，那就不用继续遍历了（不管它下面还有没有另一个结点，这一点可以后验得知）</strong>，直接返回这个目标作为候选的公共父。因为如果一个结点发现左右子树中只有一个能找到目标，那么这个目标一定是公共父节点了。</p><pre><code>代码及其简洁public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {    if(root == null || root == p || root == q) return root;    TreeNode left = lowestCommonAncestor(root.left, p, q);    TreeNode right = lowestCommonAncestor(root.right, p, q);    if(left != null &amp;&amp; right != null) return root;    return left == null ? right : left;}</code></pre><h3 id="法二：根到结点路径"><a href="#法二：根到结点路径" class="headerlink" title="法二：根到结点路径"></a>法二：根到结点路径</h3><p>可以<strong>借助dfs寻找root到两个目标结点的路径</strong>，返回一个List，头对齐之后用并行遍历的方式，一个个比对，直到不一样，那么就找到了最近公共父节点。<br>虽然不如法一直接，但是也是O(logN)的时间复杂度。</p><h3 id="扩展：找到m个结点的最近公共父节点"><a href="#扩展：找到m个结点的最近公共父节点" class="headerlink" title="扩展：找到m个结点的最近公共父节点"></a>扩展：找到m个结点的最近公共父节点</h3><p>如果用法一，那就需要两个合成一个，两个合成一个来寻找，需要O(logN^m)指数级增长的时间复杂度！<br>但是用<strong>法二</strong>的话，可以用线性时间复杂度，找到m个结点的路径，一起比对寻找最近公共父节点O(m*logN)。</p><h2 id="sqrt-牛顿法"><a href="#sqrt-牛顿法" class="headerlink" title="sqrt-牛顿法"></a>sqrt-牛顿法</h2><p>不断通过切线逼近结果的方式（二次方程）。    </p><pre><code>数学理解：输入为n，找到开方结果也就是x^2 - n = 0的解。在图像上也就是图像在x轴正向上交点。为了寻找这个交点，需要从一个起始点x1开始。（假设x1 = n）那么xi处的切线为f(xi) + f&apos;(xi)(x - xi) = y。解出xi切线与x轴交点横坐标：xi+1 = xi - f(xi) / f&apos;(xi)xi+1也就是下一个候选点横坐标，继续这一从切线接近解的方式直到x^2 - n = 0。因为此时xn的切线与x交点本身就是自己。更新方程：xi+1 = xi - f(xi) / f&apos;(xi)也就是：xi+1 = xi - (xi^2 - n) / 2*xi也就是：xi+1 = xi / 2 +  n / 2*xi</code></pre><p>数学解释：就是用开方方程<code>x^2 - n = 0</code>不断从一个起始点取切线交于x轴，与x轴的交点xi就是下一个候选点（横坐标）。这样可以不断接近实际方程的解。当点满足了<code>x^2 - n = 0</code>（或者说此时该点切线与x轴交点就是本身），那么就是答案。（从图上很好理解）</p><pre><code>long r = x;while (r*r &gt; x)    r = (r + x/r) / 2;return (int) r;   </code></pre><h3 id="扩展：限定输入输出为double，输出精度在小数点后k位"><a href="#扩展：限定输入输出为double，输出精度在小数点后k位" class="headerlink" title="扩展：限定输入输出为double，输出精度在小数点后k位"></a>扩展：限定输入输出为double，输出精度在小数点后k位</h3><p>这样的话还是可以用牛顿法。<br>如果不用牛顿法的话：二分查找，直接用mid顶替low/high。<br><strong>退出循环标志</strong>（由于精度的引入，牛顿法也要考察精度）：<code>double res*res &lt;= n + 10^-k</code> &amp;&amp; <code>double res*res &gt;= n - 10^-k</code><br>时间复杂度：<code>O(log(n*10^k))</code></p><h2 id="Moore’s-voting-Algorithm"><a href="#Moore’s-voting-Algorithm" class="headerlink" title="Moore’s voting Algorithm"></a>Moore’s voting Algorithm</h2><blockquote><p>找到一个数组中出现比例在1/k以上的所有数。（已知：最多可以有k-1个）<br>要搞懂怎么做，也要搞懂为什么可以这么做。</p></blockquote><p><a href="http://www.cs.utexas.edu/~moore/best-ideas/mjrty/example.html#step01" target="_blank" rel="noopener">图解例子：k=2的时候</a></p><pre><code>具体做法：1. 准备k-1个counter，初始值为0（分别对应候选的k-1个可能元素）（建议用List或int[]记录，方便查）（建议再用一个List tmp保存所有为0的counter编号，变相记录了有多少个候选元素）2. 准备一个数组来保存k-1个候选元素（建议使用map记录所有候选元素，key为元素，value为其对应counter编号，方便增删查）--------------------3. 遍历数组的每个元素i（以下所有情况都可以并行为一组if else）判断 i 是否在候选元素map中    a. 在的话：令其对应counter++    b. 不在的话：判断为tmp的size是否为0.（是否存在为0的counter）        （1）tmp.size() == 0：所有候选元素的counter--，若counter变为0，就删除对应map候选元素，并把这个counter加入到tmp。        注意：当出现某个counter变成0，除了删除不做其他操作，添加新的候选是下次才做。        （2）tmp.size() != 0：用tmp中最后一个counter对应这个元素并在tmp中删除（这样可以节省删除时间），保存元素到候选数组map，设置该counter为1.------------------------4. 所有map中的元素都是可能满足的候选元素。5. 再遍历一遍所有元素，统计所有map元素的出现次数，验证是否出现比例大于1/k，通过的计入结果。</code></pre><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><blockquote><p>不断凑出来k个不一样的数从数组中排除。<br>剩下的元素（应该）全是满足条件的元素。<br>因为所有出现比例大于1/k次的数一定满足每次都在删除的k个元素里，最后还能剩下它。</p></blockquote><p>首先要知道，<strong>Moore’s voting Algorithm是得到一个数组中出现比例在1/k以上的所有数的<code>必要不充分条件</code></strong>。<br>也就是说，通过Moore’s voting Algorithm得到的结果不一定是满足出现1/k的数。但是满足出现比例大于1/k的数一定可以用Moore’s voting Algorithm得到。</p><h3 id="关键及必须做的事—验证结果正确性！"><a href="#关键及必须做的事—验证结果正确性！" class="headerlink" title="关键及必须做的事—验证结果正确性！"></a>关键及必须做的事—验证结果正确性！</h3><p>由于Moore’s voting Algorithm是一个必要不充分条件，结果不一定满足出现比例大于1/k，所以要再遍历一遍统计其是否满足条件。<br>很可能筛选掉不满足的哟。</p><h2 id="Catalan数"><a href="#Catalan数" class="headerlink" title="Catalan数"></a>Catalan数</h2><p><strong>适用题型1</strong>：每一步有两种走法，但是限制此步前的a走法数&gt;=b走法数，答案是所有可能走法-所有不满足走法。即<strong><code>h(n) = C(n,2n) - C(n+1, 2n)</code></strong>。<br><strong>适用题型2</strong>：类似于动态规划、分治。<code>h(n)</code>的父问题可以由确定一个位置，剩下的分为<code>h(0)*h(n-1)</code>、<code>h(1)*h(n-2)</code>、<code>h(3)*h(n-3)</code>…、<code>h(n-1)*h(0)</code>的子问题。<strong><code>h(n) = h(0)*h(n-1) + h(1)*h(n-2) + h(2)*h(n-3) + ... + h(n-1)*h(0)</code></strong>  </p><p>（trick，如果用例子测出来，f(0)=1 f(1)=1 f(2)=2 f(3)=5 f(4)=14就一定可以用这个方法）</p><pre><code>解法公式：类似于h(n) = h(0)*h(n-1) + h(1)*h(n-2) + h(2)*h(n-3) + ... + h(n-1)*h(0)结果可以表达：h(n) = C(n,2n)/(n+1)或：C(n,2n) - C(n+1, 2n)具体问题具体分析，不一定是h(i)*h(n-1-i)由于不断地将h(i)更换为h(i-1)可以将公式总结为一个直接结果。但是计算公式会变，我就不记了。</code></pre><p>（<strong>比较好理解且适用性最高的解释：详见n对括号问题。</strong>）</p><p>适用场景：</p><h3 id="问题1：出栈顺序问题"><a href="#问题1：出栈顺序问题" class="headerlink" title="问题1：出栈顺序问题"></a>问题1：出栈顺序问题</h3><blockquote><p>进栈顺序是1~n，有多少种出栈顺序。  </p></blockquote><h3 id="问题2：n对括号，有多少种合理的组合方式"><a href="#问题2：n对括号，有多少种合理的组合方式" class="headerlink" title="问题2：n对括号，有多少种合理的组合方式"></a>问题2：n对括号，有多少种合理的组合方式</h3><p>说实话在这个问题上，不是很好理解Catalan组合方式的解释。</p><p>因为不管怎么组合，第一个括号一定是(，最后一个括号一定是)。所以就占用了一对括号。<br>所以就变成了(….)的问题。括号里是n-1个括号。<br>用严格意义的catalan就可以。</p><pre><code>PS：需要解释一下。为什么可以用严格的catalan。公式里出现了h(0)*h(n-1)、h(n-1)*h(0)，这两个实际就是一个情况呀。所以并不能用展开式来理解这个问题。实际解释：首先n对括号的全排列问题一定是C(n, 2n)，但是其中包含不满足的情况。查看所有不满足的情况，如果把(当做1，把)当做-1.那么每一种全排列都是一个数列，如果每个元素相加。那么以一种不满足的排列情况，一定存在一个位置（第一个）k，使前k个数的和&lt;0。也就是a1+a2+...+ak &lt; 0.比如：1, -1,1, -1，-1, 1，在k=5的时候和小于0.如果把前5个元素1与-1对换，就变成了：-1, 1,-1, 1，1, 1。此时相当于变成了n+1个(，n-1个)的情况。所以每一个不合法的情况都对应一个n+1个(，n-1个)的情况。其实每一个n+1个(，n-1个)的情况，都可以找到一个位置k使前k个数的和&gt;0，也就是可以返回之前不合理的情况。这样下来就相当于是一一对应关系。所以结果就是C(n,2n) - C(n+1, 2n)。也刚好是卡特兰数的公式结果。</code></pre><h3 id="问题3：矩阵连乘，用括号改变运算顺序，有多少种不同计算方式"><a href="#问题3：矩阵连乘，用括号改变运算顺序，有多少种不同计算方式" class="headerlink" title="问题3：矩阵连乘，用括号改变运算顺序，有多少种不同计算方式"></a>问题3：矩阵连乘，用括号改变运算顺序，有多少种不同计算方式</h3><blockquote><p>类似于<code>a1*a2*a3*...*an</code></p></blockquote><h3 id="问题4：n个结点构成二叉树有多少种可能"><a href="#问题4：n个结点构成二叉树有多少种可能" class="headerlink" title="问题4：n个结点构成二叉树有多少种可能"></a>问题4：n个结点构成二叉树有多少种可能</h3><p>这个问题用原始叠加公式更容易看懂。</p><h3 id="问题5：一个圆上2-n个点，多少种连接n条线段的方式，让这n个线段不相交"><a href="#问题5：一个圆上2-n个点，多少种连接n条线段的方式，让这n个线段不相交" class="headerlink" title="问题5：一个圆上2*n个点，多少种连接n条线段的方式，让这n个线段不相交"></a>问题5：一个圆上2*n个点，多少种连接n条线段的方式，让这n个线段不相交</h3><p>用原始叠加公式很好理解，相当于随便取一条线段，然后线段左右所有的点都找连接全部线段的所有方式（当然左右需要满足都是偶数个点）。当然第一条线段是后验的，只要左右各自连好，最后两个点自然是一条线段。</p><h3 id="问题6：一个凸多边形，有多少种划分方式可以将图形划分成全是三角形"><a href="#问题6：一个凸多边形，有多少种划分方式可以将图形划分成全是三角形" class="headerlink" title="问题6：一个凸多边形，有多少种划分方式可以将图形划分成全是三角形"></a>问题6：一个凸多边形，有多少种划分方式可以将图形划分成全是三角形</h3><p>同上，其实就是连接n条不相交的线段。</p><h2 id="merge-interval-meeting-room-II"><a href="#merge-interval-meeting-room-II" class="headerlink" title="merge interval    /meeting room II"></a>merge interval    /meeting room II</h2><blockquote><p><strong>题型：两个int组合成时间段，找到所有带/不带合并的时间段。</strong>  </p></blockquote><p>其实就是总结出来了一个定理：<br><strong>什么样的连续时间段是可合并的？将连续时间段的start、end去掉组合关系分别排序，一定有start[i+1]&lt;=end[i]</strong></p><blockquote><p>对象Interval包括start、end两个int，可以理解为时间段。给出一个Interval的数组，合并所有带交叉的时间段，返回合并之后的数组。<br>Given a collection of intervals, merge all overlapping intervals.<br>Input: [[1,3],[2,6],[8,15],[15,18]]<br>Output: [[1,6],[8,18]]  </p></blockquote><pre><code>先排序再遍历组合判断是否合并的方法比较容易想到和理解，就不解释了。最快正答：放弃两两一组的组合关系，取出所有的start、end分别构成两个int[]。用Arrays.sort排序两个int[].对start[i]做循环遍历，用j标记已合并结果数。每找到一个start[i+1]&gt;end[i]就代表，从j+1到i为合并对象。</code></pre><p>解释：</p><ul><li>每找到一个start[i+1]&gt;end[i]：<ul><li>由于start、end是已排序的，那么第i+1前的所有end都不可能是i+1的end，因为都比start[i+1]小。那么可以确定 j 到 i 的所有start、end元素必然是打乱前互相组合的所有元素。</li><li>由于是第一个找到的，那么可以确定 j 到 i 的所有原时间段组合，任何可行的交换，都会有前者后者时间上的交叉。</li><li>所以就代表了从 j 到 i 的所有原时间段都是可以合并的，之前取start[j]、end[i]即可。</li></ul></li></ul><h2 id="实现ArrayList的O-1-增删"><a href="#实现ArrayList的O-1-增删" class="headerlink" title="实现ArrayList的O(1)增删"></a>实现ArrayList的O(1)增删</h2><p>如果要保留数组元素顺序，那就实现不了。必须得是<strong>双向链表+map</strong>。<br>如果不用保留顺序，就用<strong>ArrayList+map</strong>实现，直接最后一个元素和被删除元素交换，删除最后一个元素就是O(1)。  </p><blockquote><p>也就是LRU+O(1)、单纯O(1)的增删 的实现区别。</p></blockquote><h3 id="PS-ArrayList的修改"><a href="#PS-ArrayList的修改" class="headerlink" title="PS ArrayList的修改"></a>PS ArrayList的修改</h3><p>java中ArrayList没有replace方法，但是有<strong>set(index, value)</strong></p><h2 id="实现一个二叉搜索-排序树"><a href="#实现一个二叉搜索-排序树" class="headerlink" title="实现一个二叉搜索/排序树"></a>实现一个二叉搜索/排序树</h2><p>首先，二叉排序树BST并不是平衡二叉树AVL，所以删除、增加没那么麻烦。</p><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>O(h)，类似于二分查找的过程。</p><h3 id="增加"><a href="#增加" class="headerlink" title="增加"></a>增加</h3><p>如果是已经存在的数，不需要增加。<br>如果是不存在的数，一定是增加在叶节点。先不断查询到不存在相应左/右节点。（并不一定是在叶节点，可能是一个节点不存在左子树，最后插到了其左孩子。）插到缺失位置。</p><h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>稍微复杂一些。</p><table><thead><tr><th style="text-align:center">删除节点类型</th><th style="text-align:center">删除方式</th></tr></thead><tbody><tr><td style="text-align:center"><strong>叶节点</strong></td><td style="text-align:center">直接删除</td></tr><tr><td style="text-align:center">左/右子树只存在一侧的<strong>非叶节点</strong></td><td style="text-align:center">直接用存在的右/左子树代替被删除节点</td></tr><tr><td style="text-align:center">左右子树都存在的<strong>非叶节点</strong></td><td style="text-align:center">1. 用左子树的最大节点（一定会是叶节点）替换到本节点；2. 用右子树的最小节点（一定会是叶节点）替换到本节点。</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;寻找连续子数组、子矩阵的和为精确值的情况&quot;&gt;&lt;a href=&quot;#寻找连续子数组、子矩阵的和为精确值的情况&quot; class=&quot;headerlink&quot; title=&quot;寻找连续子数组、子矩阵的和为精确值的情况&quot;&gt;&lt;/a&gt;寻找连续子数组、子矩阵的和为精确值的情况&lt;/h2&gt;&lt;p&gt;数组、矩阵是无序的，就没办法用窗口类的O(N、N^2)时间复杂度方法。&lt;br&gt;最简单的思考方式就是用二、三维的动态规划，计算所有i到j的情况。但是算的时候就发现了，有很多的冗余计算。&lt;/p&gt;
&lt;h3 id=&quot;DP降维—问题转化&quot;&gt;&lt;a href=&quot;#DP降维—问题转化&quot; class=&quot;headerlink&quot; title=&quot;DP降维—问题转化&quot;&gt;&lt;/a&gt;DP降维—问题转化&lt;/h3&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="blog.lovelaolao.xin/categories/Algorithm/"/>
    
      <category term="算法技巧" scheme="blog.lovelaolao.xin/categories/Algorithm/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="blog.lovelaolao.xin/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="算法" scheme="blog.lovelaolao.xin/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="高级技巧" scheme="blog.lovelaolao.xin/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    
      <category term="记忆" scheme="blog.lovelaolao.xin/tags/%E8%AE%B0%E5%BF%86/"/>
    
  </entry>
  
  <entry>
    <title>高级写法</title>
    <link href="blog.lovelaolao.xin/Algorithm/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/%E9%AB%98%E7%BA%A7%E5%86%99%E6%B3%95/"/>
    <id>blog.lovelaolao.xin/Algorithm/算法技巧/高级写法/</id>
    <published>2018-04-11T12:30:00.000Z</published>
    <updated>2018-05-28T08:39:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="矩阵四个相邻元素的高效比较–👍必用-常见"><a href="#矩阵四个相邻元素的高效比较–👍必用-常见" class="headerlink" title="矩阵四个相邻元素的高效比较–👍必用+常见"></a>矩阵四个相邻元素的高效比较–👍必用+常见</h2><p>一般和矩阵相关的BFS、DFS，都是需要对一个元素的上下左右四个元素做比较，需要每个方向上加一个限制条件是否超出了边界。一般我的做法是：（平均比较4次）</p><pre><code>if(i-1 &gt;= 0) then;if(j-1 &gt;= 0) then;if(i+1 &lt; xlen) then;if(j+1 &lt; ylen) then;也就是四个方向都判断了一次，每次做这个操作都要做四次判断。</code></pre><p>但是存在一种更加优秀的比较方式（针对矩阵）：（平均比较2.5次）<br><a id="more"></a></p><pre><code>public static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};for(int[] dir: dirs) {    int x = i + dir[0], y = j + dir[1];    if(x &lt; 0 || x &gt;= xlen || y &lt; 0 || y &gt;= ylen) continue;}相当于把四个边界判断以循环的方式放到了一个比较条件里。根据短路原则，会依次判断四个条件，那么四个方向分别需要1、2、3、4次比较，也就是平均2.5次。</code></pre><p>在计算量很大的测试用例里，如果主要时间在比较，那么会节省一半时间。<br><strong>这个trick适合在网上笔试时使用，如果超时了。</strong></p><h2 id="递归方法设计（DFS）"><a href="#递归方法设计（DFS）" class="headerlink" title="递归方法设计（DFS）"></a>递归方法设计（DFS）</h2><p>最思路清晰且容易写的方式就是：（写的时候你就知道好处了）</p><ul><li>在方法的不断向深处递归时，不设置判断，尽情的DFS递归。</li><li>在方法的入口，进行所有的可行性判断、返回判断。</li></ul><h3 id="将DFS的结果path加入List-lt-List-lt-gt-gt"><a href="#将DFS的结果path加入List-lt-List-lt-gt-gt" class="headerlink" title="将DFS的结果path加入List\&lt;List\&lt;&gt;&gt;"></a>将DFS的结果path加入List\&lt;List\&lt;&gt;&gt;</h3><p><strong><code>res.add(new ArrayList&lt;&gt;(path));</code></strong><br>因为List类型的path在递归传递中是实参，大家共享，必须new一个新的List装有path的所有元素再加入结果集合。<br>这个过程不能是简单的<code>new ArrayList&lt;&gt;() = path;</code>，还会得到path这个对象实体。<br>但是也不用遍历path元素加入到新的List里，直接用第一行的代码就可以实现只把path中所有内容加入到新的List。<br>而且从时间角度上快得多得多。</p><h2 id="自定义Arrays-sort"><a href="#自定义Arrays-sort" class="headerlink" title="自定义Arrays.sort()"></a>自定义Arrays.sort()</h2><pre><code>Arrays.sort(arr, (a, b) -&gt; a.v1 - b.v1);或Arrays.sort(arr, (a, b) -&gt; a.v1 == b.v1 ? a.v2 - b.v2 : a.v1 - b.v1);//Arrays.sort()默认按升序排序，这里相当于用了自定义的Comparator：//式2意思是：令arr的元素升序排序，如果元素的v1相等，按v2升序排序//arr, (a, b) -&gt; a.v1 - b.v1是lambda表达式//这里a、b是连续的arr中的对象//Comparator返回前者元素的value - 后者元素的value//如果把表达式相减顺序反过来就是降序了//注意a、b必须是对象，int不算是对象，Integer可以</code></pre><h2 id="Collections-sort"><a href="#Collections-sort" class="headerlink" title="Collections.sort()"></a>Collections.sort()</h2><pre><code>基本同上，不过支持对对象的排序，需要自定义comparator。</code></pre><h2 id="PriorityQueue小顶堆"><a href="#PriorityQueue小顶堆" class="headerlink" title="PriorityQueue小顶堆"></a>PriorityQueue小顶堆</h2><pre><code>//实现了queue的接口，自带一些基础方法PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;&gt;();//PriorityQueue默认小顶堆minHeap.offer(x);//添加元素（并且排序）int min = minHeap.peek();//得到堆顶元素（最小值）minHeap.poll();//出堆堆顶元素（最小值）</code></pre><h2 id="a-b-gt-c-还是-a-gt-c-b"><a href="#a-b-gt-c-还是-a-gt-c-b" class="headerlink" title="a*b &gt; c 还是 a &gt; c/b"></a>a*b &gt; c 还是 a &gt; c/b</h2><p><strong>a &gt; c/b</strong><br>（假设a b c大于0）<br>实时证明。后者比前者节省时间。<br>而且a*b容易溢出</p><h2 id="从低往高-从高往低-取int每一位"><a href="#从低往高-从高往低-取int每一位" class="headerlink" title="从低往高 从高往低 取int每一位"></a>从低往高 从高往低 取int每一位</h2><h3 id="完美写法"><a href="#完美写法" class="headerlink" title="完美写法"></a>完美写法</h3><pre><code>char[] digits = Integer.toString(num).toCharArray();而且注意，转化回原数字也快得多：Integer.valueOf(new String(digits));</code></pre><h3 id="从低往高"><a href="#从低往高" class="headerlink" title="从低往高"></a>从低往高</h3><pre><code>我总是陷在这里= =。%10就好了！！while(n &gt; 0){    int now = n % 10;    n /= 10;}</code></pre><h3 id="从高往低"><a href="#从高往低" class="headerlink" title="从高往低"></a>从高往低</h3><pre><code>int len = 0;while(n &gt; 0){    n /= 10;    len ++;}    while(len &gt; 0){    int now = n / Math.pow(10, len);    n -= now * Math.pow(10, len);    len--;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;矩阵四个相邻元素的高效比较–👍必用-常见&quot;&gt;&lt;a href=&quot;#矩阵四个相邻元素的高效比较–👍必用-常见&quot; class=&quot;headerlink&quot; title=&quot;矩阵四个相邻元素的高效比较–👍必用+常见&quot;&gt;&lt;/a&gt;矩阵四个相邻元素的高效比较–👍必用+常见&lt;/h2&gt;&lt;p&gt;一般和矩阵相关的BFS、DFS，都是需要对一个元素的上下左右四个元素做比较，需要每个方向上加一个限制条件是否超出了边界。一般我的做法是：（平均比较4次）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;if(i-1 &amp;gt;= 0) then;
if(j-1 &amp;gt;= 0) then;
if(i+1 &amp;lt; xlen) then;
if(j+1 &amp;lt; ylen) then;
也就是四个方向都判断了一次，每次做这个操作都要做四次判断。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是存在一种更加优秀的比较方式（针对矩阵）：（平均比较2.5次）&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="blog.lovelaolao.xin/categories/Algorithm/"/>
    
      <category term="算法技巧" scheme="blog.lovelaolao.xin/categories/Algorithm/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="代码书写" scheme="blog.lovelaolao.xin/tags/%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99/"/>
    
      <category term="技巧" scheme="blog.lovelaolao.xin/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="算法" scheme="blog.lovelaolao.xin/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="高级技巧" scheme="blog.lovelaolao.xin/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    
  </entry>
  
  <entry>
    <title>智力题</title>
    <link href="blog.lovelaolao.xin/Algorithm/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    <id>blog.lovelaolao.xin/Algorithm/算法技巧/智力题/</id>
    <published>2018-03-29T16:00:00.000Z</published>
    <updated>2018-05-28T08:39:13.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="用m中颜色涂分成n个扇形的圆形，保证相邻扇形颜色不同，有多少种涂法"><a href="#用m中颜色涂分成n个扇形的圆形，保证相邻扇形颜色不同，有多少种涂法" class="headerlink" title="用m中颜色涂分成n个扇形的圆形，保证相邻扇形颜色不同，有多少种涂法"></a>用m中颜色涂分成n个扇形的圆形，保证相邻扇形颜色不同，有多少种涂法</h3><p>首先，这个问题用a(n)表示，那么第一个扇形可以有m种选择，以后每个相邻的扇形都有和前一个扇形不同颜色的m-1种选择。<br>但是有一种例外情况，就是最后一个扇形和第一个扇形是相同的颜色。<br>但是这个时候，如果想计算例外情况，就是第一个最后一个绑定成一个扇形，一共有n-1个扇形，m中颜色，有多少种涂法。也就是问题a(n-1)。<br><a id="more"></a><br>也就可以变成一个数学问题：<br><img src="http://p9f9koofz.bkt.clouddn.com//扇形涂色问题推到.jpeg" alt="avatar"></p><h3 id="1000瓶水，10只老鼠，1瓶是有毒的，喝了毒水一周后死掉，如何找出这瓶水"><a href="#1000瓶水，10只老鼠，1瓶是有毒的，喝了毒水一周后死掉，如何找出这瓶水" class="headerlink" title="1000瓶水，10只老鼠，1瓶是有毒的，喝了毒水一周后死掉，如何找出这瓶水"></a>1000瓶水，10只老鼠，1瓶是有毒的，喝了毒水一周后死掉，如何找出这瓶水</h3><pre><code>很巧妙，10个老鼠可以理解为10bit，而2^10=1024 &gt; 1000，所以每个老鼠代表二进制的一位时，1000瓶水可以唯一的用10位二进制来表示，每当一只老鼠所代表的bit为1，那这只老鼠就喝这瓶水。一周之后，根据10只老鼠中死掉的几只，组成一个10位二进制数得到是第几瓶水。</code></pre><h3 id="100颗糖果，两个人轮流可以拿1-8颗糖果，我先拿，如何保证最后一颗是我拿到。"><a href="#100颗糖果，两个人轮流可以拿1-8颗糖果，我先拿，如何保证最后一颗是我拿到。" class="headerlink" title="100颗糖果，两个人轮流可以拿1~8颗糖果，我先拿，如何保证最后一颗是我拿到。"></a>100颗糖果，两个人轮流可以拿1~8颗糖果，我先拿，如何保证最后一颗是我拿到。</h3><p>这道题的关键在于，最后一颗糖的理解，我要拿到最后一颗糖，也就意味着除了这一颗的99颗两个人两个人拿正好拿完（或者剩下7颗以内）。  </p><pre><code>其实不考虑括号内的可能，理解起来更加单纯。既然每个人能拿1~8颗，那么99的因数里有3、9、11，9正好是1+8，两个人作为一组拿糖，最起码要拿9颗。  所以如果我保证不管另一个人怎么拿，我一定要拿加上他所拿的糖数位9的糖数。这样经过11轮，一定剩下一颗。  </code></pre><p>同理每个人拿1~k颗也是可以实现的。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;用m中颜色涂分成n个扇形的圆形，保证相邻扇形颜色不同，有多少种涂法&quot;&gt;&lt;a href=&quot;#用m中颜色涂分成n个扇形的圆形，保证相邻扇形颜色不同，有多少种涂法&quot; class=&quot;headerlink&quot; title=&quot;用m中颜色涂分成n个扇形的圆形，保证相邻扇形颜色不同，有多少种涂法&quot;&gt;&lt;/a&gt;用m中颜色涂分成n个扇形的圆形，保证相邻扇形颜色不同，有多少种涂法&lt;/h3&gt;&lt;p&gt;首先，这个问题用a(n)表示，那么第一个扇形可以有m种选择，以后每个相邻的扇形都有和前一个扇形不同颜色的m-1种选择。&lt;br&gt;但是有一种例外情况，就是最后一个扇形和第一个扇形是相同的颜色。&lt;br&gt;但是这个时候，如果想计算例外情况，就是第一个最后一个绑定成一个扇形，一共有n-1个扇形，m中颜色，有多少种涂法。也就是问题a(n-1)。&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="blog.lovelaolao.xin/categories/Algorithm/"/>
    
      <category term="算法技巧" scheme="blog.lovelaolao.xin/categories/Algorithm/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="blog.lovelaolao.xin/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="算法" scheme="blog.lovelaolao.xin/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="高级技巧" scheme="blog.lovelaolao.xin/tags/%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/"/>
    
      <category term="智力题" scheme="blog.lovelaolao.xin/tags/%E6%99%BA%E5%8A%9B%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>笔试技巧</title>
    <link href="blog.lovelaolao.xin/Algorithm/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/%E7%AC%94%E8%AF%95%E6%8A%80%E5%B7%A7/"/>
    <id>blog.lovelaolao.xin/Algorithm/算法技巧/笔试技巧/</id>
    <published>2018-03-24T05:03:00.000Z</published>
    <updated>2018-05-28T07:56:48.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提升成功率的技巧"><a href="#提升成功率的技巧" class="headerlink" title="提升成功率的技巧"></a>提升成功率的技巧</h2><h3 id="使用语言"><a href="#使用语言" class="headerlink" title="使用语言"></a>使用语言</h3><p>尽管C++效率高，python好写，还是写java吧。</p><h3 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h3><p>函数参数中太多递归复制的数据结构用全局变量代替，节省空间。<br>如果允许使用ide的话，必然要去用ide，要事先准备好一些基础的输入、输出、字符串处理等基本方法的书写。<br><strong>准备好一些常用的代码块。比如：输入输出的处理、</strong><br><a id="more"></a></p><h4 id="输入输出："><a href="#输入输出：" class="headerlink" title="输入输出："></a>输入输出：</h4><pre><code>import java.util.Scanner;public class Main {    public static void main(String[] args) {        Scanner sc = new Scanner(System.in);        int n = sc.nextInt();        for(int i = 0; i &lt; n; i++){            int now = sc.nextInt();        }        System.out.println(;    }}</code></pre><h4 id="查看矩阵输出对不对（检查）"><a href="#查看矩阵输出对不对（检查）" class="headerlink" title="查看矩阵输出对不对（检查）"></a>查看矩阵输出对不对（检查）</h4><pre><code>for (int i = 0; i &lt; n; i++) {        for (int j = 0; j &lt; m; j++) {            System.out.print(0 + &quot; &quot;);        }        System.out.println();    }    </code></pre><h4 id="保留几位小数的方法"><a href="#保留几位小数的方法" class="headerlink" title="保留几位小数的方法"></a>保留几位小数的方法</h4><pre><code>public static double round(double value, int places) {    if (places &lt; 0) throw new IllegalArgumentException();    long factor = (long) Math.pow(10, places);    value = value * factor;    long tmp = Math.round(value);    return (double) tmp / factor;}</code></pre><h4 id="map-put-k-v"><a href="#map-put-k-v" class="headerlink" title="map.put(k, v)"></a>map.put(k, v)</h4><pre><code>java的map的put(k,v)方法可以用于放入新元素，也可以用于更新key值所对应的value，put方法本身就会先去看value是否存在。</code></pre><h3 id="不同题型的读取方法"><a href="#不同题型的读取方法" class="headerlink" title="不同题型的读取方法"></a>不同题型的读取方法</h3><p>首先是允许一行一行读的，如果题目没给出明确要读的行数，测试的时候用一个标志结束读的情况，提交的时候用while(sc.hasNext()) 。（因为测试的时候这么写没法停止）</p><h3 id="超时"><a href="#超时" class="headerlink" title="超时"></a>超时</h3><p>超时的优化方法很多。比如：</p><ul><li>排除一些循环中没有意义的部分</li><li>排除不需要的数据结构，实际上不用也行，能用一个局部变量就别用list</li><li>找到比较费时的处理方法，换成高效的方式。如：</li></ul><h3 id="未通过所有用例"><a href="#未通过所有用例" class="headerlink" title="未通过所有用例"></a>未通过所有用例</h3><p>这个说实话可以选择性放弃，优化这个有点得不偿失，除非通过率比较低如低于40%。</p><h3 id="注意边界条件"><a href="#注意边界条件" class="headerlink" title="注意边界条件"></a>注意边界条件</h3><pre><code>int : -2^32 ~ 2^32-1即-2147483648 ~ 2147483647 大概二十多亿的大小。</code></pre><h2 id="平台区别"><a href="#平台区别" class="headerlink" title="平台区别"></a>平台区别</h2><h3 id="牛客网"><a href="#牛客网" class="headerlink" title="牛客网"></a>牛客网</h3><p>以java为例，需要自己写好main函数、main类、引用等。允许使用ide，</p><h3 id="amcat"><a href="#amcat" class="headerlink" title="amcat"></a>amcat</h3><p>微软目前使用的，其线上编译器不允许切屏，但是很好用，会自动提示方法。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;提升成功率的技巧&quot;&gt;&lt;a href=&quot;#提升成功率的技巧&quot; class=&quot;headerlink&quot; title=&quot;提升成功率的技巧&quot;&gt;&lt;/a&gt;提升成功率的技巧&lt;/h2&gt;&lt;h3 id=&quot;使用语言&quot;&gt;&lt;a href=&quot;#使用语言&quot; class=&quot;headerlink&quot; title=&quot;使用语言&quot;&gt;&lt;/a&gt;使用语言&lt;/h3&gt;&lt;p&gt;尽管C++效率高，python好写，还是写java吧。&lt;/p&gt;
&lt;h3 id=&quot;代码编写&quot;&gt;&lt;a href=&quot;#代码编写&quot; class=&quot;headerlink&quot; title=&quot;代码编写&quot;&gt;&lt;/a&gt;代码编写&lt;/h3&gt;&lt;p&gt;函数参数中太多递归复制的数据结构用全局变量代替，节省空间。&lt;br&gt;如果允许使用ide的话，必然要去用ide，要事先准备好一些基础的输入、输出、字符串处理等基本方法的书写。&lt;br&gt;&lt;strong&gt;准备好一些常用的代码块。比如：输入输出的处理、&lt;/strong&gt;&lt;br&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="blog.lovelaolao.xin/categories/Algorithm/"/>
    
      <category term="算法技巧" scheme="blog.lovelaolao.xin/categories/Algorithm/%E7%AE%97%E6%B3%95%E6%8A%80%E5%B7%A7/"/>
    
    
      <category term="技巧" scheme="blog.lovelaolao.xin/tags/%E6%8A%80%E5%B7%A7/"/>
    
      <category term="算法" scheme="blog.lovelaolao.xin/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2018-暑期实习面试总结</title>
    <link href="blog.lovelaolao.xin/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018-%E6%9A%91%E6%9C%9F/2018-%E6%9A%91%E6%9C%9F%E5%AE%9E%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>blog.lovelaolao.xin/实习面试经历/2018-暑期/2018-暑期实习总结/</id>
    <published>2018-03-08T09:31:00.000Z</published>
    <updated>2018-07-25T14:08:24.000Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="0308-momenta-视觉算法-算法开发实习生"><a href="#0308-momenta-视觉算法-算法开发实习生" class="headerlink" title="0308-momenta-视觉算法/算法开发实习生"></a>0308-momenta-视觉算法/算法开发实习生</h1><p>过程独特，预约了两个电话面试，各半小时，一面非常巧的遇到了机器学习课上老师请过来的吊学长，二面面试官还催我俩的聊天。😂。</p><p>总的来说一面学长蛮给面子的，而且也没有一开始就说是我学长，人超好，很温柔。但是判定我的机器学习-深度学习-视觉方向的知识还是不够，晕。。。所以不太适合做算法研究方向，问我愿不愿意去算法开发方向（开发sdk，除模型训练外的所有工作）。我说我纠结，人家直接不浪费时间了= =，也对。</p><p>结果是让我如果有做开发的意向联系hr再面试。总之引发了我一个问题，我愿不愿意做开发。我自己也觉得自己不太适合做算法研究，首先谈不上喜欢，我可能纯粹是想做点高端的东西。可是我又没有实验室，也没有这样的圈子，很蠢。做不了呀。</p><h2 id="面试过程"><a href="#面试过程" class="headerlink" title="面试过程"></a>面试过程</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><p>专业问题：  </p><ol><li>在做BN的时候是对一个通道做还是对一个(像素？)做？</li><li>在做BN的时候有的时候要做放缩，为什么？（在昨晚归一化特征的范围差不多的时候）</li><li>反向传播在polling层是怎样进行的？</li><li>对那些cv框架比较熟悉，vgg比如</li><li>有哪些你了解的聚类方法</li><li>有哪些你了解的分类方法</li></ol><p>数据结构问题都ok，几乎秒解。</p><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><p>保留，未面</p><h1 id="0309-格灵深瞳-计算机视觉算法实习生"><a href="#0309-格灵深瞳-计算机视觉算法实习生" class="headerlink" title="0309-格灵深瞳-计算机视觉算法实习生"></a>0309-格灵深瞳-计算机视觉算法实习生</h1><p>格灵深瞳的实习生面试就一面，难度嘛就很低，是电话面，倒是非常关注专业知识，9成都在问机器学习、深度学习相关的知识，但是都还不深，我差不多都能答出来。<br>顺便问了一下培养方式，实习生任务。大概是和mentor或者自己找idea来做小项目吧，针对一个方向，比如人脸等等。每周一汇报，很像实验室有木有。</p><h2 id="面试"><a href="#面试" class="headerlink" title="面试"></a>面试</h2><h3 id="专业知识："><a href="#专业知识：" class="headerlink" title="专业知识："></a>专业知识：</h3><ul><li>中日韩这个项目，用的什么模型（vgg19），跟之前的模型比起来有什么优点，为什么能达到这个优点？</li><li>正则化用了哪些（weight decay、dropout）？dropout的原理？</li><li>中日韩这个项目的数据量怎么样？怎么增强的？为什么要用正则化？效果提升了多少？</li><li>SVM的核函数是啥？</li><li>LR的loss是啥？为啥？</li><li>Allstate这个项目是回归还是分类项目？</li><li>应答率预估这个项目介绍下？</li><li>介绍下CNN的卷积工作原理？</li><li>卷积核的运算是怎样的？</li></ul><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><p>2sum</p><h2 id="0315-阿里巴巴-蚂蚁金服-多媒体创新组（也许叫这个）-0315一面电面随便聊聊"><a href="#0315-阿里巴巴-蚂蚁金服-多媒体创新组（也许叫这个）-0315一面电面随便聊聊" class="headerlink" title="0315-阿里巴巴-蚂蚁金服-多媒体创新组（也许叫这个）-0315一面电面随便聊聊"></a>0315-阿里巴巴-蚂蚁金服-多媒体创新组（也许叫这个）-0315一面电面随便聊聊</h2><p>神奇的6面挂之旅。<br>组的话是北京蚂蚁金服的一个做视觉的+多媒体+创新组的一个转过来的组。介绍的话说组里作过一些如扫福字的应用，肯定是要有应用落地的。听起来还蛮不错的。</p><p>问我都是简历上的东西，问了些细节，聊得蛮轻松的，有问意向：做算法研究还是开发，我说开发= =，他还夸我算法和开发都有经验的话比较有优势。。有点慌的是问我做过什么端上的开发，我说android以及服务端。。。。不会让我搞开发吧= =。</p><p>聊得比较简单，结果上应该还行吧。</p><h3 id="具体问题"><a href="#具体问题" class="headerlink" title="具体问题"></a>具体问题</h3><ul><li>在滴滴做了什么内容，内容有什么难点，有什么比较大的贡献</li><li>中日韩这个项目是分类还是人脸识别？用什么做的？效果上有什么结果吗？</li><li>allstate这个项目介绍下</li><li>智慧教室这个是课程项目还是投入使用了？你做了什么？流媒体服务器遇到过哪些问题？</li><li>车牌识别这个项目如果你现在做，打算怎么做。</li><li>你打算做研究还是工程。</li></ul><h2 id="0316二面-电话面"><a href="#0316二面-电话面" class="headerlink" title="0316二面-电话面"></a>0316二面-电话面</h2><p>大概是一面的时候看我的简历吧= =，有点犹豫，又问问我的背景，考察下我到底适合做什么，适不适合他们组。。。。</p><p>哎好吃亏啊，没有一个明确的方向去努力。。。又有什么办法呢，就是没有啊。。。</p><h2 id="0319三面-电话面"><a href="#0319三面-电话面" class="headerlink" title="0319三面-电话面"></a>0319三面-电话面</h2><p>一个面试电话面三次，我也是醉了。。这次以图像算法工程师的title面的我= =，难道是前两次之后给我归到了这？主要问了我的人脸分类、图像处理、滴滴实习的内容。<br>组也知道了：蚂蚁金服-支付宝-多媒体技术部</p><p>人脸分类：</p><ol><li>结果是怎样的，怎么算出来的？</li><li>结果是不是太好了？</li><li>考虑到中国人民族、地域可能有很大差别吗？</li><li>学长给了那些优化手段？</li><li>你觉得空间上的旋转有效吗？应该有效吗？</li></ol><p>车牌识别：</p><ol><li>遇到了什么难点吗？</li><li>图像处理上有过那些经验？</li><li>能不能识别比较特殊的车牌？</li></ol><p>滴滴实习：</p><ol><li>总结一下在滴滴的实习？</li><li>你收获最大的地方在哪里？</li></ol><h2 id="0330四面-hr面"><a href="#0330四面-hr面" class="headerlink" title="0330四面-hr面"></a>0330四面-hr面</h2><p>还以为一共是五面= =，这一面会着重问我算法题。。。到头来居然一道算法题没问。。。就到了hr面，而且也不知道结果暂时，hr面试面试流程的最后一步，也是走正常流程。问了一些比较普通的题，但是环环相扣，有点心理学的意思= =，还比较轻松。但是我觉得自己答得不是很有逻辑。</p><ol><li>说一下你对我们这边公司、部门的理解。</li><li>说一下在滴滴的实习经历，做了什么，有哪些收获，有哪些比较大的贡献</li><li>在获得的收获里遇到了那些困难，如何解决的，应该怎么解决比较好</li><li>如果别人用三个词形容你，会是哪三个词。为什么</li><li>如果你觉得你爱玩，为什么呢？</li><li>如果说到兴趣的话，你觉得对我们部门有什么兴趣</li><li>如果你觉得自己聪明，为什么呢？</li><li>你说自己对自己会有比较明确的认知和长期的计划，你对毕业之后的3-5年是怎么计划的？</li></ol><h2 id="0402五面-交叉面"><a href="#0402五面-交叉面" class="headerlink" title="0402五面-交叉面"></a>0402五面-交叉面</h2><p>终究还是要五面啊喂= =，什么第四面试终面，这一面是交叉面，别的部门的人面我，然而还是只问了项目，问了一些细节，面了20分钟吧也就= =，为毛这么轻松嘞。。。</p><p>有一点没表现好，既然这份实习都是图像相关的了，人家问你印象比较深的项目，干嘛说动态调价啊，都不算是算法相关的项目啊！！！最起码扯一下供需预估啊！！！！傻了傻了。。</p><ul><li>既然人脸分类的项目没有达到100，有没有去看测试数据，是为什么吗。—-应该答机器学习的优化原则呀，看哪部分优化的性价比最高就做什么。</li></ul><h2 id="0403六面-技术交叉面"><a href="#0403六面-技术交叉面" class="headerlink" title="0403六面-技术交叉面"></a>0403六面-技术交叉面</h2><p>尼玛！！！怎么六面都出来了，还是跳出流程微信联系。。。其实联系我主要也是为了查看我适不适合来，说白了就是既没有图像的实验室背景，也没有相关的实习经验，只有一个小项目，说实话有点虚对吧。但是考虑到你的学习能力和潜力，我还是再考察一下。😔我还是很想去的，只能听天由命啦。。突然有一种过不了的味道。。。</p><ul><li>人脸分类项目介绍。</li><li>我自己觉得我能分对中日韩，所以你这个项目的实际意义是啥？有没有资金支持还是自己做着玩的？（所以这里也能解答这个项目未来没有继续在做）</li><li>实验室方向</li><li>结果正确性质疑</li><li>动态调价介绍一下</li></ul><p>说完之后，感觉自己有点虚虚的好可怜。。。找不到自己的方向，也没能力确定自己的方向。说实话现在就是在能做什么在做什么，别人问我你想做什么。。。对不起，除了算法两个字，我说不出来一个方向。好蠢。</p><h2 id="0403-结果-挂"><a href="#0403-结果-挂" class="headerlink" title="0403-结果-挂"></a>0403-结果-挂</h2><p>😔。。。。。。。。。。。。。<br>有点沉重，果然如我所料，不断的面下去，发现最终还是一样，还是缺乏针对一个领域的专一能力、背景等。其实还是觉得自己表现的不够好，没有从人家想要的出发，没有尽量满足别人的需求，尽管很多事情不是我能决定的，但是还是有不少事情是可以我努力的。恩。。。让我悲伤一会。。。</p><p>哎，调整心态调整心态，尽管最后这个随意的结果让我很无法释怀，理由这么简单，然而在我这里的流程却这么久这么费我时间。锅还是自己背吧，事实还是证明，在图像方面实在是没什么竞争力。如果暑期实习找不到相关的，那我干脆就放弃图像这一路了。实在是竞争不过呀。<br>另外，说实话六面下来，一道算法题没做，也没有聊很久，并没给我很靠谱的印象，挂了说不定也是有好处的。<br>但是，其实自己在技术面、hr面里都有表现不好的部分，还是可以更好地，嘿嘿。。。<br>话说为什么这种奇葩的倒霉事总能发生在我身上。。。好jb。。</p><p>挂在这，我也是有点倒霉了，但是吃一堑长一智，尽管代价有点高，但是收获还是很大的，终面、交叉面的重点。掌握了没？其实操作的足够好的话，其实完全挂不了的吧。</p><h1 id="20180320-陌陌-推荐算法工程师"><a href="#20180320-陌陌-推荐算法工程师" class="headerlink" title="20180320-陌陌-推荐算法工程师"></a>20180320-陌陌-推荐算法工程师</h1><p>陌陌-视频、朋友圈各种内容的推荐-rank部门。<br>二面中一度表现很差，被吊打，最终还是给了软微以前同学、同时相识之情可能的面子，三面和leader聊了聊需求相关的想法吧，结果是过了，又聊了四面hr。<br>总体来说机器学习面的比较easy，没有深度学习的内容，问的方向也是数据相关的特征工程比如的内容。算法在二面问了两个对我来说有点难以理解的但其实需求很简单的题= =，很头疼。。。其他都比较顺溜吧。</p><h2 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h2><p>以项目为主。</p><ul><li>动调项目介绍，嘲笑了我对经济原理的提价说法。。。</li><li>有关推荐算法有什么了解？</li><li>LR给推导一下。</li><li>数据预处理做过哪些。</li></ul><h2 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h2><p>二面面试官面软微同届其他学生，然后还任务滴滴研究院、百度很多人。是从百度凤巢model组出来的大佬= =，问问题的套路感觉有点acm= =。（好像你知道acm是什么样的意义。。）<br>一度get不到题的点，结果第一题没想出来，第二题用了更低的时间复杂度做了出来。题所针对的需求都不难，但是第一题限制最好用两次mapreduce解出来，第二题最好用O(1)解出来。</p><h4 id="第一题："><a href="#第一题：" class="headerlink" title="第一题："></a>第一题：</h4><p>题：用hive/mapreduce/scala（分布式）写出来：如何将一个表user1、user2两个字段（每条代表user1关注了user2），如果互相关注了，就是好友。那么如何找到所有每个user的不是一度好友的二度好友。要求用两层MapReduce写出来。</p><p>说实话= =，我听不懂什么叫用mapreduce实现。。后来才想到，不就相当于用一个map函数一个reduce函数写咯。。其实还是挺简单的。。至于用sql的话我就有点搞不懂了= =。。。最终我还是没现场写出来。</p><h4 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h4><p>题：LRU的策略，给一个无限长（或不断增加的）数组，假设空间只有五，当空间满了会把最久未使用的那个数顶替掉。最终会是什么样的。要求时间复杂度是O(1).<br>这个题哦，我很困惑，所谓O(1)是什么，肯定不是判断完整个数组的复杂度吧= =，难道是没增加一个需要的复杂度？那我的实现方式也不是O(N)吧= =，蛋疼，什么烂题。  </p><p>考证之后发现是特么leetcode hard的题。翘李来来。</p><p>我的解法：用一个list保存5个最多的数，用一个map，key为数，value为该数的位置。分成三种情况处理并更新list和map。</p><p>面试官的解法：用双向<strong>链表</strong>+map。没搞懂哪来的O(1)，难道是不需要每个map都做更新？<br>降低操作的时间复杂度：首先双向链表的移动节点、删除、添加节点都是O(1)。<br>降低查找的时间复杂度：用map存储目前已经缓存了的内容。重点来了：这里<strong>map里的key是数字，value是链表节点本身</strong>（或是地址），这样的话当map有了变化，不需要更新其他的map键值对，只需要更新一个，当查找的时候，也不用按位置查询，直接去访问这个链表元素就好了呀。这才是链表的优势！  </p><h2 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h2><p>三面面试官就比较洋气了，没有问任何技术层面的东西，主要考察了对业务的理解，结合滴滴的实习和陌陌的场景，做了对比和联想。我觉得我答的还是可以的，和这样的人就很交流= =，最起码不会笑话你动态调价的做法。。。简直搞笑。。。</p><h2 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h2><p>hr面，被问了好多hr的套路问题。。。有的问题真的没有想到过。。至于薪酬嘛，这么远，给的也少，我应该是不会去的。。。还不如回滴滴。。或者去百度。</p><h1 id="20180329-腾讯-天天快报"><a href="#20180329-腾讯-天天快报" class="headerlink" title="20180329-腾讯-天天快报"></a>20180329-腾讯-天天快报</h1><p>啊呀呀，一面面试官临时开会换了一个面试官，应该算是比较幸运吧，而且还是本科的学长，但是并没什么卵用= =，面完才告诉我，看来是本来没打算相认的。前面技术的题答得还可以，算法题的题意理解总是偏差，可能表现扣分了。<br>但是哦天天快报又不好= =，那个地方也有点破，有点不情愿哎= =，😔。。。<br>面试过程还是很好的，面试官问问题很有耐心，而且循循善诱。就是有点面无表情。。。</p><h1 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h1><h2 id="技术题"><a href="#技术题" class="headerlink" title="技术题"></a>技术题</h2><p>技术提总体上问的很细，非常结合实践和模型建立上的重点。问问题的角度还是揭示了我很多缺点的。</p><ul><li>pid算法是怎样的，公式是怎样的，写一下。如何保证系统平衡的调节</li><li>xgboost的原理是什么？优点是什么？</li><li>为什么xgboost用到了二阶导数，有什么用吗？</li><li>供需预估，为什么不用传统的LR、svm？</li><li>LR、xgboost、svm之间有什么区别？</li><li>LR、xgboost、svm针对不同的数据集，应该选用哪个？</li><li>LR和softmax的区别是什么？</li><li>svm的原理是什么？给我推一下svm的公式吧？</li><li>有哪些特征选择的方法？</li><li>供需预估项目中，时间的特征是怎么处理的？不能说是时间戳吧？（时间片，每分钟一个）</li><li>供需预估项目中的特征工程是怎么做的？（14组，不断丰富实验）</li><li>CNN的原理给讲一下，vgg的模型给我画一下？</li><li>全连接层的效果是什么？</li></ul><h2 id="算法题-1"><a href="#算法题-1" class="headerlink" title="算法题"></a>算法题</h2><p>还是蛮不错的一道题，<strong>一个字符串比如“abc”，如何将所有的’b’删掉，所有的’a’换成’AA’，要求时间复杂度O(N)，空间复杂度O(1)。提示：b的数量大于a。</strong>   </p><p>理解：b的数量大于a，就能空出足够多的地方给a替换给的AA，所以暂时不需要额外空间。</p><pre><code>我的理解：一开始哦，理解的差好多，用list的remove、add方法遍历来删除增加，但是哦，没有想到remove、add也是O(N)的复杂度啊。。    发现这个问题后，我换成了用substring来实现remove和add，但是你怎么保证底层不是O(N)。到这里，面试官给出了硬性规定不能使用现成方法，也是帮我理解题吧，怕我跑偏。正确方法：首先遍历删除b是没问题的，但是操作的过程和删除数字里的所有0一样的原理，遍历过程中用两个指针，一个顺序遍历，一个指向非b元素的位置，这样将所有的非b元素放到数组的最后，前面全是b就行。然后实现a的替换，还是两个指针，一个在前，一个在后，把后面所有非b元素放到前面，遇到a换成AA就行了。</code></pre><p><strong>所以理解题意很重要！</strong>    </p><h1 id="413-腾讯自动驾驶-数据预处理-目标识别跟踪"><a href="#413-腾讯自动驾驶-数据预处理-目标识别跟踪" class="headerlink" title="413-腾讯自动驾驶-数据预处理-目标识别跟踪"></a>413-腾讯自动驾驶-数据预处理-目标识别跟踪</h1><p>拒了offer。<br>一开始还以为是腾讯地图，在中国技术交易大厦。原来腾讯自动驾驶、地图、游戏都有。<br>先说一下情况：本来应该是腾讯提前批结束，正式批集中面试，但是因为里的近，也可能觉得北大生源还可以，值得提前面一下。节省集中面试时间。感觉应该是一次性面完了的意思。</p><p>总之觉得这一趟感觉超级狗血= =，特别不按套路出牌。。。很蓝瘦，总体表现不尽人意，主管面的比较难，多半是跪了。。</p><p>我全程等着交流= =，然而有个屁交流，就给你闷头做题。。</p><h2 id="一面（两个半小时）"><a href="#一面（两个半小时）" class="headerlink" title="一面（两个半小时）"></a>一面（两个半小时）</h2><p>上来居然就给我主管面。。。刚来的时候主管还不在，把我领到工位等了10分钟后，另一个人跟我聊了一下实习、学校的事情，然后找了再另一个人= =，在纸上，写了两道算法题，一开始那个人又加了一道= =，然后，俩人就走了。。。。。让我写完短信联系。。。。</p><p>感觉他们都挺客气的。因为北大么（然而失望了/(ㄒoㄒ)/~~）</p><h4 id="题一"><a href="#题一" class="headerlink" title="题一"></a>题一</h4><p>设计一个算法，一个数据结构中带有x、y坐标、夹角θ，输入算法中两个数据结构对象，一个矩阵，求解3*3的矩阵使第一个坐标变成第二个坐标。</p><p>提示了有一个global坐标系。。。θ是针对这个坐标系的。。。。那又能怎样！莫名奇妙的！谁看得懂！</p><h4 id="题二"><a href="#题二" class="headerlink" title="题二"></a>题二</h4><p>冒泡排序，easy</p><h4 id="题三"><a href="#题三" class="headerlink" title="题三"></a>题三</h4><p>判断坐标系中两个三角形是否相交。</p><pre><code>我的做法：对两个三角形每个边做延长线为直线，两个三角形之间边的交点，如果交点同时在两个三角形线段上，就相交。很难计算。正答：用向量解，如果相交，一个顶点必定在另一个三角形上，这个顶点到另一个三角形每个顶点的连线向量间有一定关系，就可以判断出来了。也即是叉乘，向量之间的叉乘满足右手旋转定理，手指指向第一个向量，手心方向为第二个向量方向。大拇指方向就是叉乘结果方向。所以只要沿着一定的判定顺序，如果顶点在三角形里，那两两叉乘的向量都是一个方向的、否则就不全是。</code></pre><hr><h3 id="主管来了"><a href="#主管来了" class="headerlink" title="主管来了"></a>主管来了</h3><p>写了第二道，第三道用了比较麻烦不优秀的方法，第一道看不懂= =，然而主管来了看都没看= =，估计是前面的评价不好吧。。编码能力，主管哦，感觉很厉害，基本上听我说个两三句话就有感觉需不需要继续听了，而且问的问题都很接地气。。。是想让我好好干活吧= =。。。</p><p>最气的是，不听我解释下我题做的原因啊 = =生气。</p><h4 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h4><ul><li>多态</li><li>智慧教室编码格式</li><li>qt如何前后端交互</li></ul><h4 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h4><ul><li>TensorFlow和caffe用过没</li><li>区别和联系</li><li>optimazer之间的区别及为什么</li></ul><h4 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h4><ul><li>svm的支持向量、几何间隔、函数间隔</li><li>vgg的模型架构</li><li>数据倾斜怎么办</li><li>对于kaggle的问题，如何预处理能有比较好的效果</li></ul><h4 id="实习"><a href="#实习" class="headerlink" title="实习"></a>实习</h4><ul><li>滴滴研究院这里的情况（看来是叶老师认识的人哦）</li><li>动态调价的原理和贡献</li><li>供需预估的理解</li><li>模型是否是时序上的，模型选用的什么</li><li>特征实时的历史的如何区分</li></ul><h4 id="补一道题四（难！）"><a href="#补一道题四（难！）" class="headerlink" title="补一道题四（难！）"></a>补一道题四（难！）</h4><p>（看来前面对我的编码评价一般，蓝瘦，出的破题！）<br>找到一个字符串中最长的重复出现的连续子串的长度</p><p>没有思路交流= =，不听解释，只要结果，迷醉。</p><pre><code>我的解法：暴力，n^3，但是预计用KMP来做字符匹配，能得到n^2.正答：？？</code></pre><h2 id="复试（0419）"><a href="#复试（0419）" class="headerlink" title="复试（0419）"></a>复试（0419）</h2><p>感觉应该是一面的评价比较优，二面就面了20分钟，简单聊了聊项目、实习就ok了。然后当天面试状态更新到了hr面。</p><h2 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h2><p>也聊得比较好，半小时，具体的已经总结道HR面试经验里了，还好我前一天晚上准备的比较充分全面，还预测到了会问什么，答得比较得体。</p><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>4月24日，接到了一面主管陈仁的电话，confirm我的来意。如果接到了offer，是否回来。如果拿不定主意的话或者反悔，可能会比较麻烦人家。另外他也比较想收一个未来长期培养留在团队的候选。</p><p>顺便聊了十几分钟，给我讲了下他们在做的事。他那边是激光雷达部分的感知部分，实习生可能先做和点云坐标相关的工作。激光雷达属于自动驾驶技术里不可或缺的一部分，比图像更容易达到顶尖的水平，他的目标也是达到顶尖水准，这样未来会对自己的发展有很大帮助。</p><p>听起来蛮诱人的，再加上我也没什么offer，我就答应了先。</p><p>然后了解了下相关知识，所谓激光雷达的感知技术，原始用于比较高级的航天、航洋等的测绘。自动驾驶主要有两种感知技术，图像、激光雷达。图像的话比较直观，但是不够准确，受限于图像的信息获取技术水平，无法得到距离等信息，并且容易受到天气等影响。激光波场小的多，可以穿过树叶、雨水等不容易受影响。根据激光的反射间隔，可以描绘出车附近几米的非常精确的三维建模。</p><p>但是，目前一台精确的激光要几十万，并且一直不断发射激光扫描的方式既不安全也不科学。而且主要难点在于硬件上的性价比的降低，算法方面可能不是很有水平？很多业界内大佬都判定这个东西是自动驾驶目前必要，但是未来会被淘汰的东西。</p><p>对于我而言，也透露了主要负责点云坐标的工作（也就是激光感知的数据处理），激光感知可能就算法技术水平不够。相比微软会给单独项目的培养方式，还是不如吧= =。不如行驶规划等，所以。。。</p><p>我当天反悔啦，尽管没有offer在手，我还是决定不去了，对不起啦，感觉主管哥哥还是满照顾的。</p><p>ps：复试的胖大叔居然就是自动驾驶实验室的真正大boss，苏奎峰。。。</p><h1 id="416-阿里文娱-智能营销平台"><a href="#416-阿里文娱-智能营销平台" class="headerlink" title="416-阿里文娱-智能营销平台"></a>416-阿里文娱-智能营销平台</h1><p>跑一趟望京不容易啊。。。面了两个面试官，还特么算是一轮面试，面了两个半小时多，蓝瘦，最大的感觉就是细，问的细到头发丝。我的天爷。感觉我答完了第二天他可以去滴滴上班了，我有点不高兴了都，这是在打探情况一样。。。</p><p>我问部门也答得支支吾吾的= =，阿里文娱的非电商流量的广告，可以理解为是百度谷歌那种，但是感觉面试官有点神秘还是不自信呢= =。自己都说了移动端阿里的流量是第二，第一百度，那我为啥不去百度喔= =，但是面试难度和专业程度确实还是更高吧。。但是面试官明显不怎么看重深度学习呢？</p><p>之后有面试还会再去。。至少还有一二轮吧。。靠</p><h2 id="一面（1）"><a href="#一面（1）" class="headerlink" title="一面（1）"></a>一面（1）</h2><h3 id="1-项目-知识"><a href="#1-项目-知识" class="headerlink" title="1. 项目+知识"></a>1. 项目+知识</h3><ul><li>问了超细超细的动调项目，调什么，为什么要调，调到什么程度算是好，怎么定义这个好，没有指标吗，公式是什么，pid是滴滴发明的？这里的参数是怎么得到的，怎么确定这些参数是好的，指标是什么，每天更新参数吗，参数保存多久，你做了什么，国内的你做了什么，国际的你做了什么，怎么做的。。。。。（解释了整整一张a4纸）</li><li>应答率预估，做了什么，特征怎么得到的，有哪些，如何选择特征，如何确定不同来源的数据选哪个（难道都做实验吗，你试了多少个），模型是什么，训练要多久，单机版的吗。。。。</li><li>人脸分类，TensorFlow怎么变成分布式的，要做什么改变。</li></ul><h3 id="2-算法题"><a href="#2-算法题" class="headerlink" title="2. 算法题"></a>2. 算法题</h3><p>如何从矩阵的a走到b，最快的走法有多少种。（要求C++）</p><p>dp，简单。<br>优化：组合计算的方式，时间复杂度更高，但是不要用A/A的计算。</p><h2 id="一面（2）"><a href="#一面（2）" class="headerlink" title="一面（2）"></a>一面（2）</h2><h3 id="1-项目-知识-1"><a href="#1-项目-知识-1" class="headerlink" title="1. 项目+知识"></a>1. 项目+知识</h3><ul><li>又问了超细的动调，调什么，指标是什么，含义是什么，具体具体再具体，国际化调什么，什么情况要调，怎么调。。。。</li><li>应答率预估，预估什么。。。</li><li>人脸分类，如何提升，数据集增强怎么做的。。。</li></ul><h3 id="2-算法题-1"><a href="#2-算法题-1" class="headerlink" title="2. 算法题"></a>2. 算法题</h3><p>拿出了一个奇妙的考题纸，全是机器学习相关的，我算是答出来了7成吧，两成没答满意，一成不会。记了下没答好的。</p><ul><li>AdaBoost的时间复杂度。</li><li>不用训练的方式，如何特征选择</li><li>为什么特征离散化在某些场景可以提升模型效果</li><li>SGB的结束标志（梯度下降的距离低于预期，容易停在局部最优）</li><li>elastic net是什么样的正则化</li></ul><h1 id="417-搜狐媒体-推荐算法"><a href="#417-搜狐媒体-推荐算法" class="headerlink" title="417-搜狐媒体-推荐算法"></a>417-搜狐媒体-推荐算法</h1><p>这边面的倒也不难，表现还可以，但是可能是不够满意，也可能是他们的算法已经招满了，反正是挂了= =。</p><h2 id="一面-算法面"><a href="#一面-算法面" class="headerlink" title="一面-算法面"></a>一面-算法面</h2><p>算法小组的leader吧，比较关注深度学习水平。比较浅的都答出来了，比较深的一些没答出来。大概总结：</p><ul><li>BN的原理意义，之后的shift有什么作用，GN（Group normalization）会吗</li><li>SVM推导，由拉格朗日子乘如何解决对偶问题</li><li>xgb的特点，比gbdt的优点，目标函数</li><li>AdaBoost的时间复杂度（这算是什么问题啊= =，（m个特征，n个样本）时间：排序O(M*N*logN）+ 每次迭代O(M*N)。空间：O(M*N)</li></ul><h3 id="算法题-2"><a href="#算法题-2" class="headerlink" title="算法题"></a>算法题</h3><h5 id="1-一颗二叉树的每个节点都有权值（无重复），如何得到最大权值节点、最小权值节点的距离。"><a href="#1-一颗二叉树的每个节点都有权值（无重复），如何得到最大权值节点、最小权值节点的距离。" class="headerlink" title="1. 一颗二叉树的每个节点都有权值（无重复），如何得到最大权值节点、最小权值节点的距离。"></a>1. 一颗二叉树的每个节点都有权值（无重复），如何得到最大权值节点、最小权值节点的距离。</h5><pre><code>我的想法：距离肯定是两个节点到最近公共父节点的距离和。那么就变成了两个问题，找到最大最小权值节点，找到最近公共父节点。复杂一点可以一次遍历完成，但是好难写。简单一点，可以两、三次遍历，一次找到两个节点，再找距离。但是不好写= =，写的好慢。。</code></pre><h4 id="2-两个数组的中位数"><a href="#2-两个数组的中位数" class="headerlink" title="2. 两个数组的中位数"></a>2. 两个数组的中位数</h4><p>easy，二分查找。</p><p>时间复杂度：min(loga, logb)    </p><h2 id="二面-大数据面"><a href="#二面-大数据面" class="headerlink" title="二面-大数据面"></a>二面-大数据面</h2><p>主要了解了技能栈，实习意向，目前项目的阶段处于开始阶段，算法岗基本上差不多了，然而我笃定的不想做大数据或者开发。哎。</p><h1 id="423-微软工程院-bing-视频图片垂直搜索"><a href="#423-微软工程院-bing-视频图片垂直搜索" class="headerlink" title="423-微软工程院-bing-视频图片垂直搜索"></a>423-微软工程院-bing-视频图片垂直搜索</h1><p>总结一下微软summer intern的面试流程吧。</p><p>招进去的实习生，会单独负责一个项目，经过三个月之后根据项目情况转正。转正几率每年不同，一般是在5成以上。</p><p>尽管三面都经历了，自我感觉良好，两周多后通知挂掉了。</p><p>面试中90%都是</p><h2 id="1-网申"><a href="#1-网申" class="headerlink" title="1. 网申"></a>1. 网申</h2><p>填写许多信息网申，也可以网申之后找学长内推，不知道会有什么用吗，反正都得做笔试</p><h2 id="2-笔试"><a href="#2-笔试" class="headerlink" title="2. 笔试"></a>2. 笔试</h2><p>笔试是在amcat平台写，题不难，应该四道都写出来。</p><h2 id="3-面试"><a href="#3-面试" class="headerlink" title="3. 面试"></a>3. 面试</h2><p>4月23号集中面试，应该一共在两天，我在23号上午11点那批，一面之后管了饭，一共三面（如果有的话），当天面完，等hr通知。</p><h2 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h2><p>一面少量问了几句项目，还问了遇到问题最多的项目是什么，具体遇到了什么样的问题，怎么解决的。</p><p>然后就是做题，第二题没有用最好的做法，但也写出来了。</p><h3 id="算法题1："><a href="#算法题1：" class="headerlink" title="算法题1："></a>算法题1：</h3><blockquote><p>将一个数组的0都移到最后。</p></blockquote><p>easy，要么用交换，要么用两次循环。</p><h3 id="算法题2"><a href="#算法题2" class="headerlink" title="算法题2"></a>算法题2</h3><blockquote><p>给定正整数n，那么排列n对小括号，有多少种合理的解释。</p></blockquote><pre><code>我的解法：我先是想找到一个规律性比较好的解法，而且我也注意到了n和n-1的子问题有一些关联，但是没想好。面试官让我直接用比较蠢的方法先写。我用bfs，因为顺序从第一个单小括号开始，填够n个(和n个)就是目标情况。假设目前填了l个(和r个)。那么下次填只会是(、)其中一个。并且l、r要满足r&lt;=l&lt;=n。所以不断递归到l=n,r=n，count+1就行。显然有冗余计算。正答：卡特兰树。n的情况确实可以分。n对括号一定是第一个是(，最后一个是)。那么将一个(...)认作一个大的块。那么n情况里面可以分成两部分，左右两部分分别可能是0~n-1个括号对组成，也就是子问题。具体的去看一下卡特兰树吧~</code></pre><h2 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h2><p>二面是leader，是个很健谈人很nice的人，有夸我算法写的蛮快的，需要注意下细节。告诉我东西也比较多。代码要在白板上写。</p><p>给了一道算法题，但是比较要求细节，而且水平很棒，可以看懂我每一行代码。</p><p>代码要求我优化了两次，第二次要求二重循环，不能三重循环。第二次循环没有很好的写完。也算是写出来了。</p><p>面试官夸我代码写的挺快的，就是细节需要再注重。</p><h3 id="算法题3"><a href="#算法题3" class="headerlink" title="算法题3"></a>算法题3</h3><blockquote><p>用桶排序实现对数组的排序。要求时间复杂度O(N)。<br>写起来不容易。</p></blockquote><pre><code>我的做法：正经桶排序，n个桶，间隔为(max - min)/n。每个桶内部我用的Arrays.sort.优化要求一：面试官指出还要实现一个arrays.sort方法，所以不如用基数排序。这样就不用排序了，因为每一位数只会是0~9.中间为了获得一个数的每一位，用了老鼻子劲。但是有简单的写法：我用了bucket[最大位数][10] + index[len]。直接按顺序插入10个bucket。优化要求二：面试官指出因为bucket是二维数组，用了三重循环，可以简化到两重。因为其实bucket[最大位数]每一个数组都存了所有的数，其实用一个中间数组就好了。</code></pre><h2 id="三面-1"><a href="#三面-1" class="headerlink" title="三面"></a>三面</h2><p>三面面试官应该是总监、主管了，一个大叔，感觉得快50了= =，但是语速得是前两个面试官之和，而且问问题贼刁钻、难、奇怪= =。。。水平贼高，不知道这都是哪来的题。<br>一句项目没聊，全看逻辑思维、洞察力。。。后两道题不用写代码，只需要给出解题思路。<br>后两道题都是边聊边写的，大叔给了不少提示。至于最后一道题干脆一开始就找不到关键，降低难度后找到了一个很low的规律。</p><h3 id="算法题4"><a href="#算法题4" class="headerlink" title="算法题4"></a>算法题4</h3><p>写个二分查找热热手</p><h3 id="算法-智力题5"><a href="#算法-智力题5" class="headerlink" title="算法/智力题5"></a>算法/智力题5</h3><blockquote><p>输入为两个，第一个是一个给定魔方，每一面都是排好的同一颜色，这算是初始状态。第二个是一个打乱颜色可能是任何情况的魔方。<br>问题1：能不能从第二个魔方还原为第一个魔方。<br>问题2：魔方你觉得应该用什么数据结构来存。<br>（被面试官夸了我的洞察力蛮不错的）</p></blockquote><pre><code>题一：我的做法：首先画一个魔方。我观察到组成魔方的格子有三种。一共有顶点上的格子8个，每一面中心的格子6个，每条边中间的格子12个。顶点上的格子，与三个面连接，存在一个三种颜色的固定位置。每一面中心的格子，只有当前这面的颜色。每个顶点上的一个格子，与两个面相连，存在两个颜色间的固定位位置。凡是有多个颜色相邻的情况，无论怎么旋转魔方都不会改变其相邻颜色。注意：初始状态是给定的，也就意味着将初始状态看做一个筛子，数与数之间是存在一个固定的位置、顺序关系的。所以：    首先要判定每个面中心那个格子，相互之间是否满足原始状态的位置关系。    再判断是否存在这个颜色位置关系中，边上格子数、顶点颜色数是否数量完全一致。    都满足应该就能还原。题二：我的做法：既然有六面颜色之间的固定位置关系，那我必须定义一个正方形。满足复原条件的魔方，必然可以根据每一面中心格子旋转之后得到正方向的摆放条件。那么我就可以定义一个面的编号、面里面一定顺序（比如左上到右下）的格子编号。然后用一个二维数组cube[6][9]代表每一个面，每一个编号的颜色。其实这些编号内部会有规则联系，即可。大叔做法：我的做法相当于忘记了魔方只有三种格子的前提。还是要预订一个正方向，然后所有的中心格子、边上格子、顶点格子都自定义一种编号顺序。用三种保存1、2、3种颜色的数据结构构成三种格子，分别有6、12、8个这样的格子，即可。</code></pre><h3 id="算法-智力题6"><a href="#算法-智力题6" class="headerlink" title="算法/智力题6"></a>算法/智力题6</h3><blockquote><p>类似于华容道的题，123 456 78_，通过借助最后一个空白位置，可以让数的顺序改变。<br>问题：能不能从给定的一个打乱顺序还原会原始状态。</p></blockquote><pre><code>我的做法：我没有做法，麻蛋想不到= =。我特别想根据一个随机的例子，看什么时候是可以从打乱顺序移回原顺序的。但是一个例子就要试好久= =，移不回去的话又找不到规律。。有点懵。提醒一：想一下2*3情况，还是想不好。提醒二：想一下2*2的情况，首先发现如果只是旋转的话，会省去一下判断情况。所以1230就可以，1320就无论如何都不可以。所以我觉得2*3的时候是四个四个考虑，如果顺时针内是递增的，那就是可以复原的。以此扩展到3*3.算是糊弄过去了 = =。大叔做法：法一：不断排除竖着两个，剩下四个判断。法二：判断经历偶数、奇数次变换可以复原，如果是偶数就可以复原，奇数不可以。说的是个嘛！！！！？</code></pre><h2 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h2><p>挂了。。。</p><p>说实话其实觉得还是可以过的。。。最可怕的是，根本不知道自己是为什么没过，我真不觉得是因为第三面最后一道题没有答好挂掉了。。。除非做过这个题，怎么会知道怎么做啊= =。。。</p><p>那么难道是因为背景、经验的不足？唉。真的和微软没有缘分，我还真的是一个暑期实习的offer没有拿到哎。。。蓝瘦。    </p><h1 id="511-今日头条-抖音组推荐"><a href="#511-今日头条-抖音组推荐" class="headerlink" title="511-今日头条-抖音组推荐"></a>511-今日头条-抖音组推荐</h1><p>过程简约痛快的面试过程，还是体验不错的，两个面试官人都蛮nice，面试过程我还是有不少进步的，跟面试官没有尬住，还是聊了几句，不错不错。<br>整体过程自己有不少小瑕疵，没有表现十全十美，但是该会的地方我还是都答得不错的。收获颇丰，找到了许多可以升级的地方。<br>觉得是很不错的组，但是根据想多些时间去准备秋招，也许去不成反而不用纠结了。</p><h2 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h2><h3 id="ML"><a href="#ML" class="headerlink" title="ML"></a>ML</h3><ul><li>介绍一下在滴滴的项目。<ul><li>如何确定动调项目的参数调整（没有用grid search是吗？）是正确的。（应该这么答：因为动调的参数和计算公式紧密联系，如果调参目标是比例和幅度的话，可以比较直接的表达。如阈值、系数）</li><li>供需预估：具体化自己的工作，遇到什么问题，怎么解决，比如成都这个城市的模型优化，是遇到了什么问题，怎么分析出来问题在哪，如何优化的（随便扯了一个，成都的表现不如平均的5%，发现对一些特征比较敏感，所以尝试了不同的特征组，简化了特征）</li><li>所谓开发工具是什么</li><li>自己工作负责部分</li></ul></li></ul><h3 id="算法题一—👍"><a href="#算法题一—👍" class="headerlink" title="算法题一—👍"></a>算法题一—👍</h3><blockquote><p>传入一个double n，小数点后精度k位，返回对n的开方结果，要求满足小数点后精度。</p></blockquote><ul><li>首先，我说做过这个题，最好的方式是<strong>牛顿法</strong><ul><li>要求我推导牛顿法的计算方式、原理等</li><li>我只能画个简单的图，然后原理知道是用切线方向逼近的，但是具体的记不得了。（需要再去好好看懂）</li></ul></li><li>让换个方法<ul><li>我说使用i=0，++直到i*i&gt;n，但是要求是double都可开方，切能达到精度k</li><li>这样的话，还可以这样做，不断的确定整数位、小数第一位等等。时间复杂度<code>O(10*k/2*根号n)</code>.</li><li>仍旧是不够好，我将++的方式优化为二分查找，且提示我可以直接不管每一位每一位的，用double精度直接二分查找就行了，用mid本身更新low、high即可。</li></ul></li><li>细节不周：我的初始化为low = 0, high = n.<ul><li>但是小数呢，如果是0.01，其实是在向大于n的方向更新，所以应该是low = n, high = 1. </li><li>时间复杂度是<code>O(logn*10^k)</code></li><li>如果k=8，你觉得大概要比较多少次？几十几百几千？（几十）</li></ul></li></ul><h3 id="公式"><a href="#公式" class="headerlink" title="公式"></a>公式</h3><p>LR的目标函数，及求导全过程，完美撸完。</p><h2 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h2><h3 id="ML-1"><a href="#ML-1" class="headerlink" title="ML"></a>ML</h3><ul><li>Allstate项目<ul><li>这是个什么的项目？</li><li>如何调参（没有用grid search是吗？）</li><li>数据预处理是什么？特征的不对称性是指？不是回归问题吗，为何是对应label的数据不平衡？特征的相关性是怎么计算的？有什么用？</li><li>效果怎么样？stacking是什么？为什么没有用？</li><li>工业级为什么不怎么用stacking？（因为roi，如果费劲心思模型融合才提升了0.几，那不值，但是比赛的话，提高多少都是值的）</li><li>xgb训练了那些参数，是什么含义。</li><li>xgb的特性，gbdt和rf的区别</li><li>bagging和boosting对应bias、variance的优化区别</li><li>证明bagging能降低variance</li><li>证明bagging每个弱分类器的正确率p，整体正确率会大于p</li></ul></li></ul><h3 id="算法证明题"><a href="#算法证明题" class="headerlink" title="算法证明题"></a>算法证明题</h3><blockquote><p>证明bagging的正确率与单个基模型相比提高了。<br>假设投票决定，每个基模型相互独立（如果不相互独立的话，计算总体概率需要考虑相关性大小），且正确率为p。</p></blockquote><pre><code>我没想出来= =。提示说是一个类似微积分的证明题。。。所以列了下式子。又提示说可以用单调性证明，只要最小值都满足，那就都满足呗。那么方程可列：f(p) = sum(i,n+1~2n)(C(i, 2*n)*p^i*q^(2*n-i)) - p，证明f(p)&gt;0.其中C()为组合数计算，2*n为所有基模型的数量。但是求个屁的导数啊。。。。。</code></pre><h3 id="算法题一"><a href="#算法题一" class="headerlink" title="算法题一"></a>算法题一</h3><blockquote><p>链表逆置。easy</p></blockquote><h3 id="算法题二"><a href="#算法题二" class="headerlink" title="算法题二"></a>算法题二</h3><blockquote><p>给一个已排序数组，从中间任意位置劈开，前面后面子序列相关位置对换，找到最小值。要求快于O(N)。<br>其实可以二分查找，只需要和low位置的元素比较来更新low、high就好了。<br>如：1 2 3 4 -&gt; 3 4 1 2</p></blockquote><pre><code>所谓劈开移位就是变成了两个不同的有序序列。后面的有序序列一定每一个元素都小于前面的有序序列。最小值一定是原数组第一个，也就是移位后的后面有序序列的第一个。如果arr[mid] &gt; arr[low]，说明目前mid和low都在同一个有序序列，全局最小一定在mid之后。如果arr[mid] &lt; arr[low]，说明目前mid和low在不同有序序列里，最小值一定在mid、low之间。</code></pre><h1 id="20180514-知乎-推荐算法实习"><a href="#20180514-知乎-推荐算法实习" class="headerlink" title="20180514-知乎-推荐算法实习"></a>20180514-知乎-推荐算法实习</h1><p>可以说是目前面试了很多家表现最好的一次面试了，问的不算太简单，但是算法题也好，技术问题也好都答得很不错。<br>当下就过了，暂时没给答复。    </p><p>说下感受吧，知乎北京全在768一个创意园区里，一个鸟语花香像老干部退休养老的地方= =，知乎公司里也是非常的nice，很闲适很情怀很阳光，是一个像知乎一样的地方。总体感觉非常不错，而且公司里常能看到外面的树啊什么的，很舒服。里面的人也很nice，面试过程很舒服，感觉思路都是打开的。公司属于一种非常注重员工生活工作的感觉，大家比较融洽，还有带猫去公司、出去玩等的活动。总体感觉上是和自己的价值观比较类似的。</p><p>团队是知乎的推荐团队，是除主页之外的话题、用户等等多方面的推荐，用到的方法也比较全面。目前招的话也是招能留下的实习生。</p><p>我还是很喜欢知乎和这个公司的，可能唯一觉得不好的地方，就是一是薪资可能不能达到30以上？二是公司发展状态、规模不如滴滴以上的大厂的，所以技术、基础平台架构等等可能不完善。</p><p>但是二面面试官还是感觉很有水平的。应该还是能有收获的。目前的结论是，如果我过不了头条应该还是会去知乎吧。将来找工作如果真像hr说的能给到头条那么多，那我必须会留下的。恩。</p><h2 id="一面-5"><a href="#一面-5" class="headerlink" title="一面"></a>一面</h2><p>面试官蛮nice的，可是还是我更喜欢二面那个，主要问了项目和算法题，机器学习主要问了些传统的，没有太深太难的，全都答出来了。  </p><h3 id="算法题一-1"><a href="#算法题一-1" class="headerlink" title="算法题一"></a>算法题一</h3><blockquote><p>返回一个二叉树到任何一个结点的路径。</p></blockquote><p>DFS，用List记录路径即可。</p><blockquote><p>扩展：如何找到一棵二叉树中两个结点的最近公共父节点。</p></blockquote><pre><code>我的解法：由于在leetcode上做过这道题，就给出了这道题的解法。dfs找到要么一个子树的左右子树都含有目标结点，或者是一个在子树一个是子树根节点本身。</code></pre><blockquote><p>再扩展    ：找到一颗二叉树中m个结点的最近公共父节点。</p></blockquote><pre><code>我的解法：尽管延续扩展的解法可以解，但是需要两个两个组合解，需要解m-1次。时间复杂度O(logN ^ m-1)。指数级。提示：用原问题啊，找到所有目标的路径，头对齐，最后一个全都一样的就是父节点。时间复杂度线性级。</code></pre><h2 id="二面-4"><a href="#二面-4" class="headerlink" title="二面"></a>二面</h2><p>二面面试官明显来的就风风火火的，说话语速也比较快，问问题全是抢问和打断。基本上一张嘴就知道你会不会你的答案是不是他想要的了。<br>问了实习和项目，针对性问了些技术问题，基本上都答出来了。之前都总结过的，和一面不一样的是，问的稍有深度，且问了深度学习的项目。总体上问的不是特别细，可能觉得实习生够用了。</p><h3 id="算法题一："><a href="#算法题一：" class="headerlink" title="算法题一："></a>算法题一：</h3><blockquote><p>给出一个数组，数组中全是char，除了一个元素外其他元素全是成对出现，且相同元素相邻。最快速度返回这个只出现了一次的。</p></blockquote><pre><code>我的解法：二分查找既然相同元素相邻，那么二分查找先判断mid两侧有无相同元素。没有的话就是那个结果。有的话，判断这两个相同元素前后分成的两部分的长度。奇数长度的那部分必然是包含只出现一次的元素的。那么在这一侧继续二分查找。</code></pre><h3 id="列举一下shell中常用到的一些指令"><a href="#列举一下shell中常用到的一些指令" class="headerlink" title="列举一下shell中常用到的一些指令"></a>列举一下shell中常用到的一些指令</h3><p>netstat、ps、awk、sort。<br>问sed用过没，给一个简单问题能不能写出来。</p><h2 id="hr面"><a href="#hr面" class="headerlink" title="hr面"></a>hr面</h2><p>hr面的小姐姐可以说是非常nice的一个人，整个过程不像其他大厂的勾心斗角，各种考擦。虽然也算是考察，但是比较聊天，而且还表达了自己许多感受。总结下主要内容吧，还是有很多信息的。</p><ul><li>如果能给到头条的薪资，你会去头条还是知乎？（当然是知乎，产品我喜欢而且是诚心和有实际价值的）</li><li>对知乎的看法？（是一种非常纯粹，能学到很多内容的地方）</li><li>有什么爱好？有什么从小到大的爱好？（勾搭一下，表示知乎也有相应的兴趣小组）</li><li>薪资怎么样？（比bat高）</li><li>工作相关？（双休，管三餐，6000征个税，转正很高）</li><li>算法团队？（推荐八人，目前3实习生，在去年9月之前都属于数据团队，之后才分开的）</li><li>对一些公司的看法（以hr的圈子看，外企在中国的文化融合也好，业务技术也好都比较弱，尤其是freewheel，技术不太好，口碑也不行。。。）</li><li>已经有的offer</li><li>比较在意对知乎的看法，对头条对比的看法，和团队的融洽等</li><li>知乎在2017年才开始的校招，之前只有社招。        </li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;h1 id=&quot;0308-momenta-视觉算法-算法开发实习生&quot;&gt;&lt;a href=&quot;#0308-momenta-视觉算法-算法开发实习生&quot; class=&quot;headerlink&quot; title=&quot;0308-momenta-视觉算法/算法开发实习
      
    
    </summary>
    
      <category term="实习面试经历" scheme="blog.lovelaolao.xin/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018-暑期" scheme="blog.lovelaolao.xin/categories/%E5%AE%9E%E4%B9%A0%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/2018-%E6%9A%91%E6%9C%9F/"/>
    
    
      <category term="面试经历" scheme="blog.lovelaolao.xin/tags/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
      <category term="2018面试经历" scheme="blog.lovelaolao.xin/tags/2018%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
    
  </entry>
  
  <entry>
    <title>树形模型&amp;XGBoost</title>
    <link href="blog.lovelaolao.xin/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%A0%91%E5%BD%A2%E6%A8%A1%E5%9E%8B&amp;XGBoost/"/>
    <id>blog.lovelaolao.xin/机器学习/树形模型&amp;XGBoost/</id>
    <published>2018-03-01T14:16:00.000Z</published>
    <updated>2018-08-19T14:45:57.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-Decision-Tree-决策树"><a href="#0-Decision-Tree-决策树" class="headerlink" title="0. Decision Tree-决策树"></a>0. Decision Tree-决策树</h1><p>启发式算法</p><p>分类树：处理分类问题。<br>回归树：预测数值。</p><p>场景：用二十个问题猜出提问者脑中想好的一个事物。不断缩小范围。</p><p>决策树是一种弱分类器，简单易懂，相比复杂完善的方法，通过ensemble来组合弱分类器的方式更不容易过拟合。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p><img src="./各种熵.png" alt="avatar"><br><strong>熵</strong>：体系混乱的程度。<br><strong>信息熵（香农熵）</strong>：信息度量方式，信息越有序越低，否则反之。<br><strong>信息增益</strong>：划分数据集前后信息发生的变化。<br><strong>Gini指数</strong>：反映了在数据集中随机抽取两个样本，类别不同的概率。越低代表纯度越高。</p><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><ol><li>检测所有数据分类标签是否相同。</li><li>穷举每一个特征的每一个阈值，选择划分数据集的最好特征。（即划分之后信息熵最小，也即两个分类比例最远离1:1，信息增益最大的特征，相当于每次划分选一个特征出来，考虑所有特征，选划分之后信息熵最小-也就是信息增益（之前减之后）最大的那个，每次划分之后取出满足划分的数据集做之后的数据集）</li><li>划分数据集</li><li>创建分支节点</li><li>循环2</li><li>返回分支节点</li></ol><p>分类树（C4.5分类树）在划分数据的时候，会穷举特征每一个阈值，找到熵最小的那个。</p><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p>收集数据<br>准备数据（需要离散化的数据）<br>分析数据（计算信息熵的公式、按照特征划分数据集方法、选择最好的数据划分方式方法）<br>训练算法（创建决策树）<br>测试算法（使用决策树执行分类）<br>使用算法（可以获得树的结构）  </p><h3 id="树的纯度"><a href="#树的纯度" class="headerlink" title="树的纯度"></a>树的纯度</h3><p><strong>纯度差 = 信息增益</strong><br>一个分割点两侧的类别里，各自的同类样本的多少。（也可以理解为信息增益的其他角度理解）</p><p>纯度量化指标：（越小纯度越高）</p><ul><li>Gini不纯度</li><li>熵（Entropy）</li><li>错误率</li></ul><h2 id="构建决策树的方法比较"><a href="#构建决策树的方法比较" class="headerlink" title="构建决策树的方法比较"></a>构建决策树的方法比较</h2><table><thead><tr><th style="text-align:left">模型</th><th style="text-align:center">特点</th><th style="text-align:center">过程</th><th style="text-align:center">缺点</th></tr></thead><tbody><tr><td style="text-align:left">ID3</td><td style="text-align:center">在决策树各个子节点上应用<strong>信息增益</strong>准则选择特征，递归的构建决策树。</td><td style="text-align:center">从根节点开始，对节点计算所有可能的特征的信息增益，选择信息增益最大的特征（先筛选特征而不是穷举所有特征的可能值）作为节点的特征（然后把该特征的所有可能取值都做划分方向，各个方向选择数据子集最大的作为本节点 特征+属性值 ）；再对子节点递归调用以上方法，构建决策树。直到所有特征的信息增益均很小或没有特征可以选择为止。最后得到一个决策树。</td><td style="text-align:center">用信息增益选择属性<strong>时偏向于选择分枝比较多的属性值</strong>，即取值多的属性（因为每个可能属性可能带来比较大的分类效果及信息增益，比如id）。<strong>不能处理连续属性</strong>。<strong>不能处理属性具有缺失值的样本</strong>。<strong>容易决策树很深，过拟合</strong>。</td></tr><tr><td style="text-align:left">C4.5</td><td style="text-align:center">对ID3算法的改进，（悲观剪枝法）</td><td style="text-align:center">用<strong>信息增益率比</strong>来选择属性（具体流程完全和ID3一样只是判别标准不一样，这样对多取值特征没那么敏感了，会排除增益高且信息量也高的，如id这个特征），在决策树的构造过程中对树<strong>进行剪枝处理过拟合</strong>，<strong>对非离散数据也能处理</strong>（排序去重后用每个样本可能值做阈值转换成离散数据处理方式），<strong>能够对不完整数据进行处理</strong></td><td style="text-align:center"></td></tr><tr><td style="text-align:left">CART</td><td style="text-align:center">可用于<strong>回归、分类</strong>。<strong>二元切分法</strong>。<strong>（后剪枝）通过交叉验证递归地修剪决策树</strong>，减去使损失下降不够大的结点。从而使训练误差和测试误差达到一个很好地平衡点。支持离散、连续数据。</td><td style="text-align:center"><strong>分类树</strong>：<strong>gini指数–纯度</strong>，生成树的时候计算数据集所有特征的所有可能类别的gini指数，找最小gini指数的特征及可能值作为“是”、“否”的切分点。<strong>回归树</strong>：<strong>最小平方差</strong>（启发式分割，选取所有样本的取值做分割点）生成树的时候尝试所有样本的所有特征下的取值作为切分点将数据集一分为二，将两类数据子集的平方误差和作为判定标准，找最小平方误差和的样本特征j及切分点s。</td></tr></tbody></table><h3 id="为什么多取值属性会包含更多的熵"><a href="#为什么多取值属性会包含更多的熵" class="headerlink" title="为什么多取值属性会包含更多的熵"></a>为什么多取值属性会包含更多的熵</h3><p>因为属性取值越多就代表分类越多，什么样的数据熵比较低，当然是有序的，也就是尽量全是同类属性的数据，那么取值越多分类越多所包含的熵就越多，从熵的计算形式上也可以总结出这一结论。</p><h1 id="1-随机森林-Radam-Forest-与-AdaBoost"><a href="#1-随机森林-Radam-Forest-与-AdaBoost" class="headerlink" title="1. 随机森林-Radam Forest 与 AdaBoost"></a>1. 随机森林-Radam Forest 与 AdaBoost</h1><p>这里用到了<strong>集成方法ensemble method</strong>。<br>树太多也会拟合。</p><h2 id="随机森林-bagging"><a href="#随机森林-bagging" class="headerlink" title="随机森林-bagging"></a>随机森林-bagging</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>借助<strong>数据随机化+特征选择随机化</strong>来构建不同的决策树，提升系统的多样性。<br>注意每个决策树的数据集是有放回的抽样（比无放回的准确率更高），这样一个决策树中可能有相同的数据。（<strong>过抽样</strong>，此外还有<strong>欠抽样</strong>删除部分样本）  不做剪枝尽情生长。</p><p><strong>注意：特征的随机化，不是每个决策树随机选择了部分特征，而是决策树的每个结点在分裂的时候，随机选择m（m&lt;&lt;M）的属性来做分裂候选</strong></p><h3 id="影响RF效果的参数"><a href="#影响RF效果的参数" class="headerlink" title="影响RF效果的参数"></a>影响RF效果的参数</h3><p>随机森林分类效果（错误率）与两个因素有关：<br>（1）森林中任意两棵树的相关性：相关性越大，错误率越大；<br>（2）森林中每棵树的分类能力：每棵树的分类能力越强，整个森林的错误率越低。<br>  减小特征选择个数m，树的相关性和分类能力也会相应的降低；增大m，两者也会随之增大。所以关键问题是如何选择最优的m（或者是范围），这也是随机森林唯一的一个参数。</p><h3 id="流程-1"><a href="#流程-1" class="headerlink" title="流程"></a>流程</h3><p>构建时加入了数据随机化+特征选择随机化。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优点：几乎不需要输入准备、可以隐式特征选择、训练速度非常快、下限很高、很多优秀开源的实现。  </span><br><span class="line">能够处理高维度、离散、连续的数据。</span><br><span class="line">可以生成一个proximite矩阵，度量样本之间的相似度。（样本落在相同叶子次数/总的树数）</span><br><span class="line">容易并行化处理</span><br><span class="line">缺点：模型大小，是个很难解释的黑盒子。</span><br></pre></td></tr></table></figure><h2 id="AdaBoost-boosting"><a href="#AdaBoost-boosting" class="headerlink" title="AdaBoost-boosting"></a>AdaBoost-boosting</h2><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>包括<strong>样本的权值D和分类器的权值alpha</strong>。<br>提高每个分类器的分错样本的权值。减小投错票的分类器的权重。<br>过程是根据<strong>公式</strong>自发调节的。<br>代价函数使用true positive、fp、fn、tn来综合评估的。<br><strong>前向/加法模型，加法分步算法。</strong></p><p><strong>损失函数：指数损失函数</strong><br>e的次幂。为什么：adaboost的迭代目的是寻找最小化loss的参数α、G，他是前向分步加法算法的特例，是一个加和模型，损失函数就是指数函数。</p><p>N个样本，M维特征：<br><strong>时间复杂度</strong>：排序O(M*N*logN）+ 每次迭代O(M*N)。<br><strong>空间复杂度</strong>：O(M*N)。<br>具体需要的消耗，还要考察迭代步伐等。</p><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">优点：泛化错误率低。  </span><br><span class="line">对弱分类器的要求很低，比随机好一点就行，（比随机差的，反过来用其实也是可以用的。）</span><br><span class="line">缺点：对异常点敏感。</span><br><span class="line">数据不平衡导致分类精度下降。</span><br></pre></td></tr></table></figure><h3 id="公式推导"><a href="#公式推导" class="headerlink" title="公式推导"></a>公式推导</h3><p><img src="AdaBoost.jpeg" alt="avatar"></p><h1 id="2-回归树"><a href="#2-回归树" class="headerlink" title="2. 回归树"></a>2. 回归树</h1><p>CART（Classification and Regression Trees，分类回归树），既可以分类也可以回归。<br>将数据不断切分成易建模的块，分别建模线性回归。</p><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>用总方差来衡量数据的混乱程度。<br>以前采用ID3来切分数据。将数据按某种特征所有取值每个取值各自一份。（还有一种是按照一个拟定标准，不足和超过的分成两份）。再将连续型数据离散化。<br>CART使用二元切分，修改信息熵用总方差来度量集合无组织程度，来用数结构处理回归问题。  </p><p><strong>决策树如何做回归：</strong><br>将每个节点通过阈值区分出的两个数据组，取平均值求loss。</p><h3 id="流程-2"><a href="#流程-2" class="headerlink" title="流程"></a>流程</h3><p>数据需要都是连续型，离散型数据需要映射为二值型。<br>不断切分到不能再切分，指定为叶节点。叶节点的值大小代表训练数据当前类的标签均值。</p><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优点：可以对复杂的非线性数据建模。  </span><br><span class="line">缺点：结果很难理解。</span><br></pre></td></tr></table></figure><h2 id="树剪枝-pruning"><a href="#树剪枝-pruning" class="headerlink" title="树剪枝-pruning"></a>树剪枝-pruning</h2><p>一棵树的节点过多，容易过拟合。剪枝可以剪叶结点，也可以剪子树。</p><h3 id="预剪枝-prepruning"><a href="#预剪枝-prepruning" class="headerlink" title="预剪枝-prepruning"></a>预剪枝-prepruning</h3><p>提前停止树的增长。设定一二熵的停止阈值。节省了时间开销。<br>先验实际效果不好。原理是贪心的，所以可能带来欠拟合。</p><h3 id="后剪枝-postpruning"><a href="#后剪枝-postpruning" class="headerlink" title="后剪枝-postpruning"></a>后剪枝-postpruning</h3><p>决策树构造完成后，对拥有同样父节点的节点进行检查，判断合并后熵的增加是否小于一个阈值，那么就合并（塌陷处理）。目前是普遍做法。<br>一般会比预剪枝保留更多的分支，不容易出现欠拟合，但是需要自底向上检查，有很大的时间开销。<br>判断误差是在测试数据上判断的。</p><h2 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h2><p>定义：缺失值是指某个样本中某个属性取值的缺失，不是样本失衡、样本丢失的意思，是指样本中缺少了一个、多个值。 </p><p>常见处理方法：</p><ul><li>插值法（Imputation）： QUEST, CRUISE</li><li>替代法（Alternate/Surrogate Splits）：CART， CRUISE</li><li>缺失值单独分支（Missing value branch）：CHAID， GUIDE</li><li>概率权重（Probability weights）： C4.5</li></ul><p>总的来说有两个问题：  </p><table><thead><tr><th style="text-align:left">模型</th><th style="text-align:center">当存在属性值缺失，如何划分属性</th><th style="text-align:center">已知属性划分，缺失属性值的样本如何划分</th></tr></thead><tbody><tr><td style="text-align:left">ID3</td><td style="text-align:center">不计入该属性样本集中缺失属性值的样本训练，按剩下样本比例乘以信息增益。（相当于逃避不处理）</td><td style="text-align:center">逃避</td></tr><tr><td style="text-align:left">C4.5</td><td style="text-align:center">缺失属性值的样本进入所有可能分类分支，给所有样本加一个权重，（缺失属性值样本的权重变成各个分支中样本比例。）</td><td style="text-align:center">以不同的权重比例进入所有可能分支。（其实就是给之后统计结果加入权重概念）</td></tr><tr><td style="text-align:left">xgb</td><td style="text-align:center">训练的时候，将所有缺失属性值的数据全都导向到所有划分方向，假设他们属于所有属性值。然后比对各个方向哪个结果是最优的。</td><td style="text-align:center">选择训练时缺失属性值的数据进入的分支结果最优的分支划分。</td></tr></tbody></table><h2 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h2><p>就是每一个划分节点中不止包含一个属性划分，还有其他属性划分结合在一起。<br>这样在样本空间的决策边界就不再是平行于坐标轴（属性），而是“斜”的决策边界了。<br>常用算法：OCI。</p><h2 id="模型树"><a href="#模型树" class="headerlink" title="模型树"></a>模型树</h2><p>把叶节点设定成分段线性函数。<br>误差计算：先用模型拟合，然后计算真实目标与预测值之间的误差平方和。<br>在图像上表示由之前的线性回归变成了折线的线性回归。</p><h1 id="3-GBDT-梯度提升决策树"><a href="#3-GBDT-梯度提升决策树" class="headerlink" title="3. GBDT-梯度提升决策树"></a>3. GBDT-梯度提升决策树</h1><p>GBDT (Gradient Boosting Decision Tree) 又叫 MART （Multiple Additive Regression Tree)，是一种迭代的决策树算法，该算法由多棵决策树组成，所有树的结论累加起来做最终答案。它在被提出之初就和SVM一起被认为是泛化能力（generalization)较强的算法。近些年更因为被用于搜索排序的机器学习模型而引起大家关注。  </p><p>首先知道<strong>GBDT中的树都是回归树，不是分类树</strong>， GBDT的核心在于累加所有树的结果作为最终结果。</p><p>（<strong>GBM-gradient boosting machine</strong>）</p><p><strong>GBDT的思想使其天然可以发现多种有区分性的特征及特征组合<br>，所以工业界常用于LR的上一层模型，如Facebook的CTR预估</strong></p><h2 id="原理-4"><a href="#原理-4" class="headerlink" title="原理"></a>原理</h2><h3 id="Gradient-Boosting-梯度迭代"><a href="#Gradient-Boosting-梯度迭代" class="headerlink" title="Gradient Boosting-梯度迭代"></a>Gradient Boosting-梯度迭代</h3><p><strong>GBDT的核心就在于，每一棵树学的是之前所有树结论和的残差，这个残差就是一个加预测值后能得真实值的累加量</strong>。  </p><p><strong>选择特征</strong>：用<strong>CART TREE</strong>选择特征。先遍历训练样本的所有的特征，对于特征 j，我们遍历特征 j 所有特征值的切分点 c。找到可以让下面这个式子最小的特征 j 以及切分点c. </p><p><strong>残差</strong>： A的预测值 + A的残差 = A的实际值 </p><p><strong>Gradient</strong>：所以这里把前一棵树的预测结果的残差，给下一棵树训练，让z整体结果向全局最优的方向进行就是所谓的Gradient。（但并不是求导那种Gradient）</p><p><strong>损失函数</strong>：均方误差（回归）和LogLoss（分类）等。<br><img src="GBDT损失函数.png" alt="avatar"></p><p><strong>计算步长</strong>：用牛顿法计算步长，辅助shrinkage收缩步长防止过拟合。</p><p>计算结果：将所有树的结果*缩放因子 相加即预测结果。</p><p><strong>Boosting</strong>：每一步计算残差的过程也正是boosting对权重的修改。（虽然与AdaBoost不同）</p><pre><code>举例说明：A的真实年龄是18岁，但第一棵树的预测年龄是12岁，差了6岁，即残差为6岁。  那么在第二棵树里我们把A的年龄设为6岁去学习，如果第二棵树真的能把A分到6岁的叶子节点，那累加两棵树的结论就是A的真实年龄；如果第二棵树的结论是5岁。则A仍然存在1岁的残差，第三棵树里A的年龄就变成1岁，继续学。</code></pre><h3 id="算法流程"><a href="#算法流程" class="headerlink" title="算法流程"></a>算法流程</h3><p><img src="GBDT算法流程.png" alt="avatar"></p><ol><li>rim为回归树m-1的负梯度，被当回归树m做残差的估计（也就是回归树m的yi）。</li><li>对rim捏合一棵回归树，回归树的叶子结点区域为Rmj，</li><li>线性搜索出来γjm使损失函数最小（也就是该区域对应取值，也就是落在该区域的样本本次迭代应该涨多少：γjm）</li><li>更新总体模型fm(x)（加和）</li></ol><h4 id="为什么要用负梯度作为残差的估计（最速下降方法）？？"><a href="#为什么要用负梯度作为残差的估计（最速下降方法）？？" class="headerlink" title="为什么要用负梯度作为残差的估计（最速下降方法）？？"></a>为什么要用负梯度作为残差的估计（最速下降方法）？？</h4><p>用泰勒一阶展开式可证明：（<strong>泰勒二阶展开式可以证明xgb梯度下降的原理</strong>）<br><img src="DBDT优化目标及负梯度理论.jpeg" alt="avatar"></p><h3 id="特点-3"><a href="#特点-3" class="headerlink" title="特点"></a>特点</h3><p>一般的回归树容易过拟合，只要叶子足够多，就能达到很高的训练数据准确度，但是泛化很差。  </p><pre><code>优点：  并且GBDT通过梯度迭代的方式，需要了更少的特征。  GBDT的适用范围非常广，几乎适用所有回归问题，还有二分类问题。  不需要做特征归一，可以自动选择特征。缺点：  串行过程。  计算复杂度高。  不适用高维稀疏数据。</code></pre><p>对弱分类器的要求比较简单，能达到低方差高偏差就行，因为迭代过程是针对偏差的。</p><p>相比<strong>RF关注树的数量</strong>，<strong>GBDT关注每棵树的深度</strong>（一般是1）。</p><h3 id="Shrinkage"><a href="#Shrinkage" class="headerlink" title="Shrinkage"></a>Shrinkage</h3><p>Shrinkage的思想是：类似于step。每次走一小步逐渐逼近结果的效果，要比每次迈一大步很快逼近结果的方式更容易<strong>避免过拟合</strong>。即它不完全信任每一个棵残差树，它认为每棵树只学到了真理的一小部分，累加的时候只累加一小部分，通过多学几棵树弥补不足。</p><p>也就是把每次计算出的残差拿出一部分给下一棵树学习，只累加一小部分。将陡变变成渐变。</p><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p>shrinkage（收缩步长）和采样比例可以理解为正则化的手段。</p><h3 id="用GBDT构造特征"><a href="#用GBDT构造特征" class="headerlink" title="用GBDT构造特征"></a>用GBDT构造特征</h3><p>建GBDT的多棵决策树，每个叶子节点可以理解为一维特征，落在该叶节点就是1，未落在就是0.再加上原来的特征一起输入到如LR中，可以有显著的效果提升。<br>相当于用GBDT的训练结果作为特征组合的方式。</p><h3 id="GBDT用于分类"><a href="#GBDT用于分类" class="headerlink" title="GBDT用于分类"></a>GBDT用于分类</h3><p><a href="https://zhuanlan.zhihu.com/p/25257856?refer=data-miner" target="_blank" rel="noopener">GBDT解决分类</a><br>解决回归问题的时候是计算残差得到最优，但是分类问题没办法计算残差，类别之间没办法比较。  </p><p>分类的时候损失函数使用<strong>log损失函数</strong>，评估最大化预测值为真实值的概率，为什么：参考了最大似然估计的计算原理。</p><p>有较多公式推导。</p><h2 id="搜索引擎排序应用-RankNet"><a href="#搜索引擎排序应用-RankNet" class="headerlink" title="搜索引擎排序应用 RankNet"></a>搜索引擎排序应用 RankNet</h2><h1 id="4-XGBoost"><a href="#4-XGBoost" class="headerlink" title="4. XGBoost"></a>4. XGBoost</h1><p><a href="https://blog.csdn.net/han_xiaoyang/article/details/52665396" target="_blank" rel="noopener">整体知识</a><br>Gradient Boosting的一种高效系统实现，不是一种单一算法，xgboost里面的基学习器除了用tree(gbtree)（这里相当于对GBDT的优化），也可用线性分类器(gblinear)。<br>传统GBDT以CART作为基分类器，xgboost还支持线性分类器，加了剪枝。</p><h2 id="原理-5"><a href="#原理-5" class="headerlink" title="原理"></a>原理</h2><h3 id="构造回归树"><a href="#构造回归树" class="headerlink" title="构造回归树"></a>构造回归树</h3><h4 id="（1）贪心算法"><a href="#（1）贪心算法" class="headerlink" title="（1）贪心算法"></a>（1）贪心算法</h4><p><img src="./贪婪算法.png" alt="avatar"></p><h4 id="（2）近似算法-加速-减小内存消耗"><a href="#（2）近似算法-加速-减小内存消耗" class="headerlink" title="（2）近似算法 - 加速+减小内存消耗"></a>（2）近似算法 - 加速+减小内存消耗</h4><p><img src="./近似算法.png" alt="avatar"></p><h3 id="特点-4"><a href="#特点-4" class="headerlink" title="特点"></a>特点</h3><ol><li>显示的把树模型复杂度作为<strong>正则项</strong>加到了<strong>目标函数</strong>中。</li><li>公式推导中用到了<strong>二阶导数</strong>，用了<strong>二阶泰勒展开</strong>。<ol start="3"><li>展开点是上一个树的结果。对权重w求导，令导数为0。</li><li>在后面划分桶的时候，还将二阶导数h作为每个样本的权重。（代表划分通的间距）</li></ol></li><li>残差：划分前后的误差增益。</li><li><strong>并行化处理</strong>—系统设计模块,块结构设计等<ol start="7"><li>xgboost还设计了高速缓存压缩感知算法</li><li>exact greedy algorithm采用缓存感知预取算法 </li><li>approximate algorithms选择合适的块大小</li></ol></li><li>CPU cache命中优化。</li><li>灵活，支持多种分类器，适用多种场景。</li><li><strong>行、列抽样</strong>。类似于RF的随机化处理，降低了反差（相关性），防止了过拟合。</li><li>Built-in Cross-Validation（内置交叉验证)</li><li>continue on Existing Model（接着已有模型学习）</li></ol><h3 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a>创新点</h3><ol><li><strong>pre-sorted算法</strong>：数据事先排序并且以<strong>block</strong>形式存储。（有利于并行计算）<ol start="2"><li><strong>column block for parallel learning</strong>：预排序（减少建树时间）+block（减少排序时间），block的排序相当于是对每个特征，用他们的值来排序，每个值是一个指针，指向那条数据。这样每个特征可以分开排序，不用去存储整条数据。</li></ol></li><li><strong>exact greedy algorithm贪心算法</strong>（老版划分算法）：遍历所有特征及所有取值（<strong>已排序</strong>，两重循环），用分裂前后总loss（loss是当前这棵树所要拟合的loss）变化来做信息增益的计算。（非并行）</li><li><strong>approximate algorithm可并行的近似直方图算法</strong>（最明显提升的优化措施）：近似算法，根据特征的分布来（密集的分布区域采样多，稀疏的地方采样少）<strong>分成桶</strong>，把所有样本放入对应的桶，用桶来计算增益。减少了计算量。</li><li><strong>weighted quantile sketch</strong>：采样时，让候选点之间的距离不小于一个值。</li><li><strong>sparsity-aware splict finding缺失值处理，稀疏性利用</strong>：针对特征稀疏的情况，针对这种情况，让所有缺失值尝试所有进入左、右分裂方向，哪个增益大进入哪个。（进入一个分裂方向会一直走到头，再去试另一个方向）</li></ol><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><h3 id="增加随机性"><a href="#增加随机性" class="headerlink" title="增加随机性"></a>增加随机性</h3><ul><li><strong>eta</strong> 这个就是学习速度，也就是上面中的ϵ。</li><li><strong>subsample</strong> 这个就是随机森林的方式，每次不是取出全部样本，而是有放回地取出部分样本。有人把这个称为行抽取，subsample就表示抽取比例。</li><li><strong>colsample_bytree</strong> 和<strong>colsample_bylevel</strong> 这个是模仿随机森林的方式，这是列抽取。colsample_bytree是每次准备构造一棵新树时，选取部分特征来构造，colsample_bytree就是抽取比例。colsample_bylevel表示的是每次分割节点时，抽取特征的比例。（列抽样-防止过拟合）</li><li><strong>max_delta_step</strong> 这个是构造树时，允许得到ft(x)的最大值。如果为0，表示无限制。就是每棵树权重改变的最大步长。</li></ul><h3 id="防止过拟合（正则化-剪枝）"><a href="#防止过拟合（正则化-剪枝）" class="headerlink" title="防止过拟合（正则化+剪枝）"></a>防止过拟合（正则化+剪枝）</h3><ul><li><strong>max_depth</strong> 树的最大深度（剪枝）</li><li><strong>min_child_weight</strong> 如果一个节点的权重和小于这玩意，那就不分了。（后剪枝？）</li><li><strong>gamma</strong> 指定了节点分裂所需的最小损失函数下降值。这个参数值越大，算法越保守。（后剪枝？）</li><li><strong>alpha</strong> 和<strong>lambda</strong> 就是目标函数里的表示模型复杂度中的L1范数和L2范数前面的系数。</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><strong>booster</strong> 表示用哪种模型，一共有gbtree, gbline, dart三种选择。一般用gbtree。</li><li><strong>nthread</strong> 并行线程数。如果不设置就是能采用的最大线程。</li><li><strong>sketch_eps</strong> 这个就是近似算法里的ϵ。</li><li><strong>scale_pos_weight</strong> 这个是针对二分类问题时，正负样例的数量差距过大。把这个参数设置为一个正数，可以使算法更快收敛。</li><li><strong>objective</strong> 定义需要被最小化的损失函数。默认[reg：linear]。还包括[binary：logistic]二分类的逻辑回归，返回概率而非类别。[multi:softmax]使用softmax的多分类器，返回预测的类别。</li></ul><h3 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h3><ul><li>xgb的损失函数是什么，这个是可以自定义的，针对不同问题有各自适用的，如log、平方等</li><li><strong>xgb的目标函数</strong><ul><li><img src="./xgb目标函数.png" alt="avatar"></li><li><img src="./xgb目标函数正则项.png" alt="avatar"></li></ul></li></ul><h1 id="5-lightGBM"><a href="#5-lightGBM" class="headerlink" title="5. lightGBM"></a>5. lightGBM</h1><p><a href="https://blog.csdn.net/xwd18280820053/article/details/68927422" target="_blank" rel="noopener">多种树形分类器比较</a><br>首先GBDT的缺陷在于不能mini batch，效率太差，所以需要分布式的GBDT。</p><p>lightGBM使用了基于 histogram 的决策树算法。<br>xgboost（单机exact greedy算法/分布式dynamic histogram）选用了另一个主流决策树算法pre-sorted。</p><p>简单来说lgb比xgb的优点在于，使用histogram选择分割点的时候更加好，在构建决策树的计算过程有优化。</p><h3 id="histogram-VS-pre-sorted"><a href="#histogram-VS-pre-sorted" class="headerlink" title="histogram VS pre-sorted"></a>histogram VS pre-sorted</h3><ul><li>使用histogram算法（直方图算法）降低了训练数据在内存中的存储空间。</li><li>在构建决策树的时候，和pre-sorted算法一样需要O(data*feature)的时间复杂度来寻找分割点。但是histogram需要O(data)的时间复杂度来分割数据。pre-sorted需要O(data*feature)。因为他们的排序、索引方式不同。</li><li>histogram大幅减少了计算分割点增益的次数。计算分割点所有可能值的方式不同（也源于存储方式的不同）。</li><li>并行通信上histogram省去了大量的代价。这一点xgboost在并行通信上也是用histogram。</li><li>histogram不能精确的找到分割点，且训练误差没有pre-sorted优秀。（但是整体的模型效果上并不差或者会更好（可能粗分割可以带来正则化））</li><li>总的来说AUC和xgb差不多。</li><li>训练速度更快，收敛贼快。</li></ul><h3 id="创新点-1"><a href="#创新点-1" class="headerlink" title="创新点"></a>创新点</h3><ul><li><strong>GOSS：Gradient-based one-side sampling</strong>：完善增益定义。<ul><li>令数据按梯度排序，选topk大梯度的数据作为子集A，剩下的随机选部分作为子集B。（因为梯度大的数据更有用，减少了切分的时候的候选数量）</li><li>每次训练一个新树的时候选一次，相当于训练每棵树之前的抽样。</li></ul></li><li><strong>EFB：exclusive feature bundling</strong>：互斥特征绑定，合并成一个特征。（因为互斥不为0，针对稀疏的特征很好用）<ul><li>也对连续特征离散化。训练速度再次加强（相比xgb）。</li></ul></li></ul><h3 id="lightGBM的其他优化（VS-xgboost）"><a href="#lightGBM的其他优化（VS-xgboost）" class="headerlink" title="lightGBM的其他优化（VS xgboost）"></a>lightGBM的其他优化（VS xgboost）</h3><ul><li>不用大多数GBDT的按层生长，而用带有深度限制的按叶子生长 (leaf-wise) 算法。（level-wise容易多线程优化且不容易过拟合，但是效率过低。尽管leaf-wise容易树深度加深，过拟合，但是可以限制深度。且提高了效率。）</li><li>（并行方面）在直方图上也省去了冗余计算。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;0-Decision-Tree-决策树&quot;&gt;&lt;a href=&quot;#0-Decision-Tree-决策树&quot; class=&quot;headerlink&quot; title=&quot;0. Decision Tree-决策树&quot;&gt;&lt;/a&gt;0. Decision Tree-决策树&lt;/h1&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="机器学习" scheme="blog.lovelaolao.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="树模型" scheme="blog.lovelaolao.xin/tags/%E6%A0%91%E6%A8%A1%E5%9E%8B/"/>
    
      <category term="XGB" scheme="blog.lovelaolao.xin/tags/XGB/"/>
    
  </entry>
  
  <entry>
    <title>朴素贝叶斯</title>
    <link href="blog.lovelaolao.xin/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    <id>blog.lovelaolao.xin/机器学习/朴素贝叶斯/</id>
    <published>2018-01-16T11:29:00.000Z</published>
    <updated>2018-05-28T08:20:11.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-原理"><a href="#1-原理" class="headerlink" title="1. 原理"></a>1. 原理</h1><pre><code>C = {y1, y2, y3, ....., ym} 类别集合，共k种样本类别。x = {x1, x2, ..., xn} 样本特征表示，共n个特征。</code></pre><p>条件概率公式：<br><img src="http://p9f9koofz.bkt.clouddn.com/条件概率.png" alt="avatar"><br><a id="more"></a><br>全概率公式：<br><img src="http://p9f9koofz.bkt.clouddn.com/全概率公式.png" alt="avatar"><br>贝叶斯定理（事件A/B相互独立）<br><img src="http://p9f9koofz.bkt.clouddn.com/贝叶斯定理.png" alt="avatar"></p><h1 id="2-分类推导"><a href="#2-分类推导" class="headerlink" title="2. 分类推导"></a>2. 分类推导</h1><p>朴素贝叶斯分类是基于贝叶斯定理的分类算法。</p><h2 id="2-1-离散型随机变量推导"><a href="#2-1-离散型随机变量推导" class="headerlink" title="2.1 离散型随机变量推导"></a>2.1 离散型随机变量推导</h2><p>分析：<br>选择具有最高概率的决策。计算新样本x在类标记结合中的概率。<br>P(y_1|x)、P(y_2|x)…….P(y_k|x)。</p><h3 id="重点在这里"><a href="#重点在这里" class="headerlink" title="重点在这里"></a>重点在这里</h3><blockquote><p>所以朴素贝叶斯公式为：<br><img src="http://p9f9koofz.bkt.clouddn.com/离散朴素贝叶斯.png" alt="avatar"><br>根据全概率公式改写为：<br><img src="http://p9f9koofz.bkt.clouddn.com/离散全概率朴素贝叶斯.png" alt="avatar">  </p><blockquote><p>其中P(yk)可由数据直接获得。问题在于P(x|yk)如何得到。<br>x = {x1, x2, …., xn}，如果每个特征都满足相互独立。<br>那么P(x|yk) = P(x1, x2, …, xn | yk) =<br><img src="http://p9f9koofz.bkt.clouddn.com/p(x|yk" alt="avatar">.png)    </p></blockquote></blockquote><p>带回原式得到最后结果：<br><img src="http://p9f9koofz.bkt.clouddn.com/离散朴素贝叶斯公式.png" alt="avatar"> </p><h2 id="2-2-连续型随机变量推导"><a href="#2-2-连续型随机变量推导" class="headerlink" title="2.2 连续型随机变量推导"></a>2.2 连续型随机变量推导</h2><p>若数据特征属性为连续型值，该值服从高斯分布，即：<br><img src="http://p9f9koofz.bkt.clouddn.com/连续高斯分布.png" alt="avatar"><br>这里每个类别y都有n（特征维数）个不同的高斯分布。（共m*n个）<br>同理将P(ak|yi)带回朴素贝叶斯公式的P(xi|yk)即可。</p><h1 id="3-常用模型"><a href="#3-常用模型" class="headerlink" title="3. 常用模型"></a>3. 常用模型</h1><p>朴素贝叶斯的模型里不一定只有离散或连续的一种特征，可能需要结合计算。如：性别、身高、体重。</p><h2 id="3-1-多项式"><a href="#3-1-多项式" class="headerlink" title="3.1 多项式"></a>3.1 多项式</h2><p>离散特征。<br>用多项式模型对公式进行平滑处理。</p><h2 id="3-2-高斯"><a href="#3-2-高斯" class="headerlink" title="3.2 高斯"></a>3.2 高斯</h2><p>连续特征。</p><h2 id="3-3-伯努利"><a href="#3-3-伯努利" class="headerlink" title="3.3 伯努利"></a>3.3 伯努利</h2><p>离散特征。<br>每个特征的取值只能是1或者0.</p><h1 id="4-异常处理"><a href="#4-异常处理" class="headerlink" title="4. 异常处理"></a>4. 异常处理</h1><h2 id="4-1-拉普拉斯平滑"><a href="#4-1-拉普拉斯平滑" class="headerlink" title="4.1 拉普拉斯平滑"></a>4.1 拉普拉斯平滑</h2><p>在连乘的特征概率的部分，避免一个特征的概率是0，可以在分子上加一个参数λ。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;1-原理&quot;&gt;&lt;a href=&quot;#1-原理&quot; class=&quot;headerlink&quot; title=&quot;1. 原理&quot;&gt;&lt;/a&gt;1. 原理&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;C = {y1, y2, y3, ....., ym} 
类别集合，共k种样本类别。
x = {x1, x2, ..., xn} 
样本特征表示，共n个特征。
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;条件概率公式：&lt;br&gt;&lt;img src=&quot;http://p9f9koofz.bkt.clouddn.com/条件概率.png&quot; alt=&quot;avatar&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="机器学习" scheme="blog.lovelaolao.xin/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="blog.lovelaolao.xin/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="朴素贝叶斯" scheme="blog.lovelaolao.xin/tags/%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF/"/>
    
  </entry>
  
  <entry>
    <title>C++刷题语法</title>
    <link href="blog.lovelaolao.xin/Language/C/C++%E5%88%B7%E9%A2%98%E8%AF%AD%E6%B3%95/"/>
    <id>blog.lovelaolao.xin/Language/C/C++刷题语法/</id>
    <published>2018-01-11T13:49:00.000Z</published>
    <updated>2018-05-28T07:55:40.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h3 id="判断是否存在"><a href="#判断是否存在" class="headerlink" title="判断是否存在"></a>判断是否存在</h3><pre><code>res = xx.find(??);if(res != xx.end())    存在;</code></pre><a id="more"></a>    <h3 id="判断是否插入成功"><a href="#判断是否插入成功" class="headerlink" title="判断是否插入成功"></a>判断是否插入成功</h3><pre><code>res = xx.insert(??);if(res.second)    成功;res会是一个pair，first是一个iterator，second是插入结果反馈。</code></pre><h2 id="string"><a href="#string" class="headerlink" title="string"></a>string</h2><h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><pre><code>string.at()</code></pre><h3 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h3><h2 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h2><pre><code>int array[x][y];行高：sizeof(array)列高：sizeof(array[0])vector&lt;vector&lt;?&gt;&gt; a(长度，vector&lt;?&gt;(长度，初始化))</code></pre><h2 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h2><h3 id="查询-1"><a href="#查询-1" class="headerlink" title="查询"></a>查询</h3><pre><code>pair.firstpair.secondx.insert(make_pair&lt;?, ?&gt;(?, ?))</code></pre><h2 id="map-lt-gt"><a href="#map-lt-gt" class="headerlink" title="map&lt; , &gt;"></a>map&lt; , &gt;</h2><h3 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h3><pre><code>insert(make_pair&lt;int, int&gt;(i, j));需要用pair的形式insert</code></pre><h3 id="查询-2"><a href="#查询-2" class="headerlink" title="查询"></a>查询</h3><pre><code>map[key]v = map.find(key) 得到的是一个迭代器，迭代器指向一个pairv-&gt;first得到keyv-&gt;second得到value</code></pre><h2 id="vector-lt-gt"><a href="#vector-lt-gt" class="headerlink" title="vector&lt;&gt;"></a>vector&lt;&gt;</h2><h3 id="查询-3"><a href="#查询-3" class="headerlink" title="查询"></a>查询</h3><pre><code>vector[i]vector.at(i)</code></pre><h3 id="尾部操作"><a href="#尾部操作" class="headerlink" title="尾部操作"></a>尾部操作</h3><pre><code>vector.push_back()vector.pop_back()</code></pre><h2 id="queue-lt-gt"><a href="#queue-lt-gt" class="headerlink" title="queue&lt;&gt;"></a>queue&lt;&gt;</h2><pre><code>queue.push(i)入队一个元素queue.pop()出队一个元素，但是不返回结果queue.front()返回队首元素</code></pre><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="传参"><a href="#传参" class="headerlink" title="传参"></a>传参</h2><p>vector、map等数据结构在函数传入参数那里需要加上&amp;符号。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构&quot;&gt;&lt;a href=&quot;#数据结构&quot; class=&quot;headerlink&quot; title=&quot;数据结构&quot;&gt;&lt;/a&gt;数据结构&lt;/h1&gt;&lt;h3 id=&quot;判断是否存在&quot;&gt;&lt;a href=&quot;#判断是否存在&quot; class=&quot;headerlink&quot; title=&quot;判断是否存在&quot;&gt;&lt;/a&gt;判断是否存在&lt;/h3&gt;&lt;pre&gt;&lt;code&gt;res = xx.find(??);
if(res != xx.end())
    存在;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Language" scheme="blog.lovelaolao.xin/categories/Language/"/>
    
      <category term="C++" scheme="blog.lovelaolao.xin/categories/Language/C/"/>
    
    
      <category term="C++" scheme="blog.lovelaolao.xin/tags/C/"/>
    
      <category term="代码书写" scheme="blog.lovelaolao.xin/tags/%E4%BB%A3%E7%A0%81%E4%B9%A6%E5%86%99/"/>
    
  </entry>
  
  <entry>
    <title>HDFS+MapReduce-思考题</title>
    <link href="blog.lovelaolao.xin/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/2.HDFS+MapReduce/"/>
    <id>blog.lovelaolao.xin/面经总结/2.HDFS+MapReduce/</id>
    <published>2018-01-06T16:00:00.000Z</published>
    <updated>2018-07-25T13:48:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>hadoop = HDFS + MapReduce</p><h1 id="HDFS"><a href="#HDFS" class="headerlink" title="HDFS"></a>HDFS</h1><p>DFS即分布式文件系统，分布式文件存储在多个机器组成的集群中，用来管理分布式文件存储的系统称之为分布式文件系统。</p><p>HDFS即Hadoop分布式文件系统，它擅长存储大文件，流式读取，运行于一般性的商业硬件上。HDFS不适合存储大量的小文件，namenode会在内存中存储元数据，通常情况下每个文件、目录和块都将占用150个字节；也不适合任意并发写的场景，HDFS的写文件操作是append的模式。</p><p>在HDFS中，文件被分割成不同的块存储在集群的数据节点里，文件系统的元数据由文件系统集中管理。<br><a id="more"></a></p><h4 id="block"><a href="#block" class="headerlink" title="block"></a>block</h4><p>抽象出块的概念，可以让文件大小超过整个磁盘。</p><h4 id="namenode"><a href="#namenode" class="headerlink" title="namenode"></a>namenode</h4><p>管理文件系统的命名空间，位数文件系统树、所有文件、目录、块的元数据。<br>拥有block和datanode之间的映射，但不持久化这些信息，需要datanode启动时的报告。</p><h4 id="datanode"><a href="#datanode" class="headerlink" title="datanode"></a>datanode</h4><p>nomenode选取副本存储在datanode节点。</p><h4 id="datanode选取策略"><a href="#datanode选取策略" class="headerlink" title="datanode选取策略"></a>datanode选取策略</h4><h1 id="MapReduce（spark）"><a href="#MapReduce（spark）" class="headerlink" title="MapReduce（spark）"></a>MapReduce（spark）</h1><p>MapReduce程序运行分为两个阶段，map和reduce。每个阶段都由key-value这种形式的数据做为输入输出。<br>Key和Value类必须通过实现Writable接口来实现序列化。此外，Key类必须实现WritableComparable 来使得排序更简单。<br>MapRedeuce job 的输入输出类型：(input) -&gt;map-&gt;combine-&gt;reduce-&gt; (output)  </p><p>首先每个MapReduce任务都是一个job。</p><h4 id="0-注意"><a href="#0-注意" class="headerlink" title="0. 注意"></a>0. 注意</h4><ul><li>整个过程应减少磁盘io，尽量使用内存。能百倍提升速度。</li><li>MapReduce默认做排序的操作。</li><li>整个map、reduce阶段都可以算作shuffle的阶段。</li></ul><h4 id="1-input-phase"><a href="#1-input-phase" class="headerlink" title="1. input phase"></a>1. input phase</h4><p>通过一个record reader对输入文件中的每一条数据转换为键值对的形式，并将数据发送给Mapper。<br>Map只读取<strong>split</strong>，split与hdfs上的基本单元block可能是一对一或者一对多的关系。</p><h4 id="2-Map"><a href="#2-Map" class="headerlink" title="2. Map"></a>2. Map</h4><p>可以是用户自定义的函数，对接收到的键值对进行指定处理，生成0个或多个键值对。<br>这里分割map每个节点的结果，按照指定方式映射给不同的reduce的过程，也叫做<strong>partition</strong>。</p><h4 id="3-intermediate-keys"><a href="#3-intermediate-keys" class="headerlink" title="3. intermediate keys"></a>3. intermediate keys</h4><p>由mapper生成的键值对。<br><img src="https://raw.githubusercontent.com/Namsto/mapreduce/master/images/phases.jpg" alt="avatar"><br>这个结果会进入<strong>spill溢写过程</strong>，将结果写入内存缓冲区，然后发给reduce。这里如果缓冲区容量不足，也会临时写入磁盘。<br>（溢写过程也算是map里的）整个map task结束以后会把多次溢写产生的溢写文件<strong>merge</strong>成一个。（多次溢写也是因为map的结果过大，缓冲区不够，需要磁盘中介分批完成）（这里的merge与reduce的计算不同，是把相同key的value组成group放入同一个溢写文件。）</p><h4 id="4-shuffle-and-sort"><a href="#4-shuffle-and-sort" class="headerlink" title="4. shuffle and sort"></a>4. shuffle and sort</h4><p>Reducer任务从shuffle和sort开始，程序把分好组的键值对数据下载到本机，Reducer会在本机运行。<br>将独立的键值对数据按照键值排序合成一个较大的数据序列，数据序列中键值相等的键值对数据会被分在相同的一组，方便Reducer做迭代操作。</p><h4 id="5-Reducer（Combiner）"><a href="#5-Reducer（Combiner）" class="headerlink" title="5. Reducer（Combiner）"></a>5. Reducer（Combiner）</h4><p>首先通过<strong>copy</strong>，简单的拉取数据，reduce进程会启动一些数据copy线程<strong>Fetcher</strong>，通过http方式请求map task所在TaskTracker获取map task的输出文件（本地磁盘）。<br>然后将从不同map端copy来的数据做<strong>merge</strong>，copy的数据会先放在内存缓冲区（这里的缓冲区大小更为灵活），细节与map的merge类似。得到一个最终的溢写文件。（可能在内存，也可能在磁盘）<br>最后进入<strong>reduce</strong>阶段。Reducer任务把分好组的键值对数据作为输入，对每一个键值对执行Reducer函数。程序会用指定方式对数据合并、筛选。执行完毕后会生成0个或多个键值对数据，提供给最后一个处理步骤。  </p><h4 id="6-output-phase"><a href="#6-output-phase" class="headerlink" title="6. output phase"></a>6. output phase</h4><p>通过record reader把从Reducer函数输出的键值对数据按照一定格式写入文件。</p><p>过程如下：<br><img src="https://raw.githubusercontent.com/Namsto/mapreduce/master/images/mapreduce_work.jpg" alt="avatar"></p><h2 id="shuffle"><a href="#shuffle" class="headerlink" title="shuffle"></a>shuffle</h2><h3 id="意义"><a href="#意义" class="headerlink" title="意义"></a>意义</h3><p>完整的从map task端拉取数据到reduce端。<br>在跨节点拉取数据的时候，尽可能减少对带宽的不必要消耗。<br>减少磁盘IO对task执行的影响。</p><h3 id="溢写过程不影响map线程"><a href="#溢写过程不影响map线程" class="headerlink" title="溢写过程不影响map线程"></a>溢写过程不影响map线程</h3><p>内存缓冲区默认有0.8的空间，当达到0.8会写入磁盘，此时还有0.2的内存可以给map线程用。</p><h3 id="RPC"><a href="#RPC" class="headerlink" title="RPC"></a>RPC</h3><p>每个reduce task不断地通过RPC从JobTracker那里获取map task是否完成的信息。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;hadoop = HDFS + MapReduce&lt;/p&gt;
&lt;h1 id=&quot;HDFS&quot;&gt;&lt;a href=&quot;#HDFS&quot; class=&quot;headerlink&quot; title=&quot;HDFS&quot;&gt;&lt;/a&gt;HDFS&lt;/h1&gt;&lt;p&gt;DFS即分布式文件系统，分布式文件存储在多个机器组成的集群中，用来管理分布式文件存储的系统称之为分布式文件系统。&lt;/p&gt;
&lt;p&gt;HDFS即Hadoop分布式文件系统，它擅长存储大文件，流式读取，运行于一般性的商业硬件上。HDFS不适合存储大量的小文件，namenode会在内存中存储元数据，通常情况下每个文件、目录和块都将占用150个字节；也不适合任意并发写的场景，HDFS的写文件操作是append的模式。&lt;/p&gt;
&lt;p&gt;在HDFS中，文件被分割成不同的块存储在集群的数据节点里，文件系统的元数据由文件系统集中管理。&lt;br&gt;
    
    </summary>
    
      <category term="面经总结" scheme="blog.lovelaolao.xin/categories/%E9%9D%A2%E7%BB%8F%E6%80%BB%E7%BB%93/"/>
    
    
      <category term="大数据" scheme="blog.lovelaolao.xin/tags/%E5%A4%A7%E6%95%B0%E6%8D%AE/"/>
    
      <category term="思考题" scheme="blog.lovelaolao.xin/tags/%E6%80%9D%E8%80%83%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>LintCode算法.md</title>
    <link href="blog.lovelaolao.xin/Algorithm/LintCode/LintCode%E7%AE%97%E6%B3%95/"/>
    <id>blog.lovelaolao.xin/Algorithm/LintCode/LintCode算法/</id>
    <published>2017-09-29T10:17:00.000Z</published>
    <updated>2018-05-28T07:56:36.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据结构–矩阵"><a href="#数据结构–矩阵" class="headerlink" title="数据结构–矩阵"></a>数据结构–矩阵</h1><pre><code>int[][] arr;arr.length:行数arr[1].length:第二行的元素数（列数）</code></pre><h2 id="和为零的子矩阵—👍👍👍"><a href="#和为零的子矩阵—👍👍👍" class="headerlink" title="和为零的子矩阵—👍👍👍"></a>和为零的子矩阵—👍👍👍</h2><p>提供一个矩阵，寻找一个和为0的子矩阵。返回子矩阵的左上角下标和右下角下标。</p><p><strong>学会了：一个矩阵（矩形）所有元素的和dp[i][j][x][y]可以由dp[0][0][x][y]、dp[0][0][x][j-1]、dp[0][0][i-1][y]、dp[0][0][i-1][j-1]计算得来。</strong></p><a id="more"></a><h3 id="n-4"><a href="#n-4" class="headerlink" title="n^4"></a>n^4</h3><p>哎，第一反应是dp，还好是可以做的。<br>时间复杂度是优化的n^4，因为要考虑起终点，一共有四个int。</p><pre><code>dp[i][j][x][y]表示从i,j到x,y的矩阵和的大小。每个dp[i][j][x][y] = dp[i][j][x-1][y] + dp[i][j][x][y-1] - dp[i][j][x-1][y-1] + arr[i][j]所以一定会写四层循环。前两层确定起点，后两层确定重点。</code></pre><p>写起来比较麻烦，思路不难，但是数据太大会死掉。<br>为了达到题目要求的n^3的时间复杂度要求，可以做一次很骚的变换。</p><blockquote><p>回头看起来，神奇的想法🤦‍♀️，还真能做出来。</p></blockquote><h3 id="n-3-（太难想了）"><a href="#n-3-（太难想了）" class="headerlink" title="n^3 （太难想了）"></a>n^3 （太难想了）</h3><p>在写四层循环的时候就可以发现了，每个起点都要计算一个单独的dp矩阵。而实际上这个矩阵的计算有很多冗余。</p><p>但是思考问题的方式：起点-重点 的思路限制了必须这样做。</p><p>但是转换角度后，可以发现：</p><pre><code>dp[i][j][x][y] = dp[0][0][x][y] - dp[0][0][x][j-1]- dp[0][0][i-1][y] + dp[0][0][i-1][j-1]即把起终点的矩阵块，由起点为0，0到终点为x，y的矩阵块分割得到然而从0，0到x，y的矩阵是所有起点都共享的，只需要计算一次。</code></pre><p>所以就变成了n^3.  个鬼啦！<br><strong>用dp[i][j]表示从0，0到i，j的矩阵的和就够了。</strong><br>这里求得所有的dp[i][j]就已经用了n^2，然后还要求sum[i][j][x][y]也要双层循环。</p><p>目前为止只是转化了一下思考方式，算是打下了基础。<br>我们来看公式：</p><pre><code>sum[i][j][x][y] = dp[x][y] + dp[i][j] - dp[x][j] - dp[i][y]如果要满足sum为0，也就意味着0 = dp[x][y] + dp[i][j] - dp[x][j] - dp[i][y]</code></pre><p>我们转换一下公式：    </p><pre><code>dp[x][y] - dp[x][j] = dp[i][y] - dp[i][j]</code></pre><p>这里明显的公式两侧就变成了三个参数。所以通过三层循环计算出所有的dp[x][y] - dp[x][j]，然后在遍历一遍寻找相等的两个值。（带着i、j、x、y的条件。）<br>这才是n^3。</p><h2 id="排序矩阵中的从小到大第k个数—👍👍👍"><a href="#排序矩阵中的从小到大第k个数—👍👍👍" class="headerlink" title="排序矩阵中的从小到大第k个数—👍👍👍"></a>排序矩阵中的从小到大第k个数—👍👍👍</h2><p>矩阵每一行都是从小到大排序好的。<br>要求时间复杂度klogn。</p><h3 id="我的思路："><a href="#我的思路：" class="headerlink" title="我的思路："></a>我的思路：</h3><p>由于选出前k个最小的元素的最快算法是堆排序，所以打算用堆排序。<br>但是还要考虑如何选出建堆的元素们。</p><blockquote><ol><li>先选出足够k个元素建堆，原理是，先选出一个矩阵，矩阵长度为sqrt(k)+1。然后把除小矩阵右下角（最大值）右下侧元素的所有元素加入考虑。</li><li>此时堆里一定有足够多的元素，然后输出到第k个元素。</li></ol></blockquote><p>所以准备两个方法，一个heapify方法，一个建堆+出堆的方法。</p><p>但是写着写着发现，太特么蠢了，也太难写了。</p><h3 id="优化一下："><a href="#优化一下：" class="headerlink" title="优化一下："></a>优化一下：</h3><blockquote><p>因为上一个思路最大的问题是选出来足够的元素来堆排序，但是选择的标准很容易就到了n^2。</p></blockquote><blockquote><p>所以打算改用插入排序的思想，准备一个有序集合，不断更新已经确定一定是这样的位置的长度。</p></blockquote><blockquote><p>但是这样实际上不是插入排序了，是归并，还不是分治思想的归并。说白了就是把矩阵前几列列入了考虑，一旦前几列的数据比较稀疏，那就相当于把整个矩阵全都排序了。nlogn不满足。</p></blockquote><h3 id="正答："><a href="#正答：" class="headerlink" title="正答："></a>正答：</h3><p>实际上即不需要堆排序（还是需要的）、也不需要插入排序等等。也不需要一个有序序列。因为输出的只是一个结果而已。只是单纯的以行为单位顺序遍历就行了。</p><blockquote><p>因为要输出第k小的那个元素，那么循环k次输出整个矩阵的最小的那个。</p></blockquote><blockquote><p>因为每一行的数据都是从小到大的，那么矩阵里的元素就不需要重复遍历<br>到，最多每个元素遍历一次。</p></blockquote><blockquote><p>用一个数组来保存每一行元素中，在k次遍历里还没被选出来的第一个元素。</p></blockquote><pre><code>k次遍历每次都需要遍历每一行。用flag保存本次遍历最小元素产生在了哪行。用temp保存本次遍历中目前的最小值。用result保存每次遍历结果的最小值，最终输出result。</code></pre><p>目前为止可以实现kn的复杂度。因为每次遍历相当于选出来了n个元素，再找到最小那个。<br>所以借助堆排序，用n个元素来建堆，然后输出堆顶，加入新的元素。直到输出k个。所以是O(klogn)</p><h2 id="矩阵归零"><a href="#矩阵归零" class="headerlink" title="矩阵归零"></a>矩阵归零</h2><p>如果矩阵中一个元素（原始的）是0，那么把其所在行、列都置0.<br>easy：用两个set储存有哪些行、列存在0元素。遍历一次所有元素即可。</p><h2 id="搜索二维矩阵-II"><a href="#搜索二维矩阵-II" class="headerlink" title="搜索二维矩阵 II"></a>搜索二维矩阵 II</h2><p>矩阵可以理解为是一个排序好的数据，截成一行一行组成的矩阵。<br>目标：O(log(n) + log(m))</p><h3 id="第一印象"><a href="#第一印象" class="headerlink" title="第一印象"></a>第一印象</h3><p>可以用一个int min标记每一行最小的大于等于目标元素的位置。那么下一行最多遍历到这个点即可，并且更新这个min。</p><p>结束标志：min = 0。</p><p>bingo！</p><h3 id="正答"><a href="#正答" class="headerlink" title="正答"></a>正答</h3><p>显然是二分查找</p><h2 id="接雨水-II-—👍👍"><a href="#接雨水-II-—👍👍" class="headerlink" title="接雨水 II —👍👍"></a>接雨水 II —👍👍</h2><p>根据矩阵所代表的海拔图来计算能接住多少雨水。<br>目标：O(n)时间 O(1)/O(n)空间</p><h3 id="first-thought（wrong）"><a href="#first-thought（wrong）" class="headerlink" title="first thought（wrong）"></a>first thought（wrong）</h3><p>因为凡是可以蓄雨水的地方，都和周围四个格子能蓄多少水有关系。所以应该是DP。</p><p>dp[i][j]代表第i,j个格子可以蓄多少水。  </p><pre><code>1.最外一圈的dp[i][j] = 0.（补：倒数第二圈的元素直接相连的倒数第一圈的元素里如果有比自己矮的，倒数第二圈的这个元素也为0.）  2.周围都比自己矮dp[i][j] = 0.3.dp[i][j] = 周围四个格子比自己高的格子所能蓄的水的和 + 与周围比自己高的格子里最低的格子高的差（补：如果周围有比自己矮的且已知dp为0的或者那个元素加上自己的dp都不如自己高，那么自己必然无法蓄水）</code></pre><p>这样看起来好像是对的，但是如果存在一个地中海的情况，中间有一个比周围都高的，但是这个又比外圈都低，这样的算法是不计入考虑的，然而却有积水。  </p><p>并且还存在，一个较高的元素，需要自己比自己矮的元素的蓄水数，但是比自己矮的那个蓄水数反过来还需要自己的蓄水数。那就悖论了。</p><p>太难全面写好，初步版本过了41%的数据。</p><p>总的来说要是被面到了这个题，这种思路100%gg。</p><h3 id="improve（暴力，但是最起码是bug-free）"><a href="#improve（暴力，但是最起码是bug-free）" class="headerlink" title="improve（暴力，但是最起码是bug free）"></a>improve（暴力，但是最起码是bug free）</h3><p>换个角度用动调，将这样一个立体的图像从高度上分析，一层一层的铲这个图像。<br>那么就简单了，因为不需要考虑每个空档能蓄多少水，因为一层只能蓄水一个。</p><pre><code>dp[][] + i 代表第i层每个格子是否可以蓄水。true/false。每一层之后会计数：如果这一层没有实心的格子退出。是否可以蓄水：判断上下左右这一层的四个格子是否是空的            如果四周有格子为空，那么先暂时置自己的为true            然后递归的形式去看为空的格子能不能蓄水。稍微优化一下：从最低格子的高度遍历到最高格子的高度。但是效率好低</code></pre><p>这种思路也不算是动调了，这是DFS。</p><h3 id="正答看不懂。。。所以还是用最蠢的吧"><a href="#正答看不懂。。。所以还是用最蠢的吧" class="headerlink" title="正答看不懂。。。所以还是用最蠢的吧"></a>正答看不懂。。。所以还是用最蠢的吧</h3>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;数据结构–矩阵&quot;&gt;&lt;a href=&quot;#数据结构–矩阵&quot; class=&quot;headerlink&quot; title=&quot;数据结构–矩阵&quot;&gt;&lt;/a&gt;数据结构–矩阵&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;int[][] arr;
arr.length:行数
arr[1].length:第二行的元素数（列数）
&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&quot;和为零的子矩阵—👍👍👍&quot;&gt;&lt;a href=&quot;#和为零的子矩阵—👍👍👍&quot; class=&quot;headerlink&quot; title=&quot;和为零的子矩阵—👍👍👍&quot;&gt;&lt;/a&gt;和为零的子矩阵—👍👍👍&lt;/h2&gt;&lt;p&gt;提供一个矩阵，寻找一个和为0的子矩阵。返回子矩阵的左上角下标和右下角下标。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;学会了：一个矩阵（矩形）所有元素的和dp[i][j][x][y]可以由dp[0][0][x][y]、dp[0][0][x][j-1]、dp[0][0][i-1][y]、dp[0][0][i-1][j-1]计算得来。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="blog.lovelaolao.xin/categories/Algorithm/"/>
    
      <category term="LintCode" scheme="blog.lovelaolao.xin/categories/Algorithm/LintCode/"/>
    
    
      <category term="LintCode" scheme="blog.lovelaolao.xin/tags/LintCode/"/>
    
      <category term="Matrix" scheme="blog.lovelaolao.xin/tags/Matrix/"/>
    
  </entry>
  
</feed>
